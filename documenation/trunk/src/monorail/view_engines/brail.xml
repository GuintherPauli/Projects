<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../../../toolchain/docbook-xml/docbookx.dtd">
<section>
	<title>Brail</title>
	<para>
		<emphasis>Pros:</emphasis>
		<itemizedlist>
			<listitem>
				<para>
					Use the wrist friendly and feature-rich
					<ulink url="http://boo.codehaus.org">
						Boo language
					</ulink>
					for templates.
				</para>
			</listitem>
			<listitem>
				<para>Compiled (good performance!)</para>
			</listitem>
		</itemizedlist>
	</para>
	<para>
		<emphasis>Cons:</emphasis>
		<itemizedlist>
			<listitem>
				<para>Requires additional assemblies</para>
			</listitem>
			<listitem>
				<para>
					Python syntax (which one can consider as a pro)
				</para>
			</listitem>
		</itemizedlist>
	</para>
	<para>
		Brail is a view engine for MonoRail which allows you to use the
		same framework and Boo language on both ends of the application.
		You write the business logic using Boo (or any other .Net
		language), and then you write the views in Boo. No need for a
		mental switch or learn another templating language.
	</para>
	<section>
		<title>Getting Started</title>
		<para>
			Brail includes many changes to the way that you normally
			write code in Boo. Brail views are scripts files that ends
			with "*.brail" or "*.brailjs". The most significant change
			is that Brail does not use whitespace to control blocks.
			This mean that the following statement in Boo:
		</para>
		<programlisting lang="cs"><![CDATA[
if someCondition:
   DoAction()
]]></programlisting>
		<para>Will look like this in Brail:</para>
		<programlisting lang="cs"><![CDATA[
if someCondition:
   DoAction()
end
]]></programlisting>
		<para>
			Blocks are controlled starting with a colon and ending by
			"end". While this is probably the most significant change
			from Boo, there are many other things that Brail does for
			you so you would get a scripting experience while working in
			a compiled langauge. Read on and discover what makes Brail
			so special.
		</para>
		<section>
			<title>Referencing Assemblies</title>
			<para>
				First of all you must reference the following
				assemblies. Copy them to the bin folder if you are not
				using Visual Studio.
			</para>
			<para>
				<itemizedlist>
					<listitem>
						<para>Castle.MonoRail.Views.Brail.dll</para>
					</listitem>
					<listitem>
						<para>Boo.Lang.dll</para>
					</listitem>
					<listitem>
						<para>Boo.Lang.Compiler.dll</para>
					</listitem>
					<listitem>
						<para>Boo.Lang.Parser.dll</para>
					</listitem>
					<listitem>
						<para>anrControls.Markdown.dll</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				The Boo.* files are required for the language support.
				The anrControl.Markdown.dll is required for support
				<ulink
					url="http://www.aspnetresources.com/blog/markdown_announced.aspx">
					Markdown
				</ulink>
				formatting.
			</para>
		</section>
		<section>
			<title>Configuration</title>
			<para>
				Edit your web.config file to include the following line
				(in the monoRail config section, of course):
			</para>
			<programlisting lang="html"><![CDATA[
<viewEngine 
	viewPathRoot="Views" 
	customEngine="Castle.MonoRail.Views.Brail.BooViewEngine, Castle.MonoRail.Views.Brail" />
]]></programlisting>
			<para>
				And that is it, you are now capable of using
				<ulink url="http://boo.codehaus.org">Boo</ulink>
				scripts to write views in MonoRail! Now that you can use
				it, let's see what you can do with it.
			</para>
			<para>
				Before we get to how to use it, I must send
				<emphasis>huge</emphasis>
				thanks to the Boo Community, for being so helpful.
			</para>
			<para>
				If your view directory is in the web directory, it's
				wise to not allow the files to be read through http. So
				under the system.web/httpHandlers configuration you
				should add the following:
			</para>
			<programlisting lang="html"><![CDATA[
<add verb="*" path="*.brail" type="System.Web.HttpForbiddenHandler"/>
<add verb="*" path="*.brailjs" type="System.Web.HttpForbiddenHandler"/>
]]></programlisting>
		</section>
		<section>
			<title>Using It</title>
			<para>
				First, Brail scripts are not normal
				<ulink url="http://boo.codehaus.org">Boo</ulink>
				programs, they ''require'' that you would have at least
				one statement at the global namespace, which is what
				MonoRail will end up calling when your view is invoked.
				Assuming that you've already have a controller, and that
				you've setup your environment correctly, you can simply
				do this:
			</para>
			<programlisting lang="html"><![CDATA[Hello, World!]]></programlisting>
			<para>
				Brail will take this script, compile it and send its
				output to your browser. The nice thing about it is that
				if you would change it to say:
			</para>
			<programlisting lang="html"><![CDATA[Hi, World!]]></programlisting>
			<para>
				You will instantly get a the updated view, this is
				highly important to development scenario.
			</para>
			<note>
				<para>
					This is a developer feature, meant to ease
					development. Using it on a production machine would
					cause recompiling of the scripts and cause an
					''assembly leak'' until the application domain is
					restarted. On a developer machine, this should
					rarely be a problem, on a production machine, if
					frequent changes are made to the scripts, this can
					cause problems.
				</para>
			</note>
			<para>
				You can also use parameters that the controller has put
				in the Property Bag or Flash, like this:
			</para>
			<programlisting lang="html"><![CDATA[Hi, ${User}!]]></programlisting>
			<para>
				If you are wondering how does it work behind the scenes:
				the script is loaded and compiled. There is some magic
				there that sends anything not wrapped in &lt;% %&gt;
				directly to the user (which will also expand ${arg}
				expression to their values). The compiled code is
				cached, so you pay the compilation cost only once.
			</para>

			<programlisting lang="html"><![CDATA[
<html>	
	<head>		
		<title>${title}</title>
	</head>	
	<body>	    
	     <p>The following items are in the list:</p>  
	     <ul><%for element in list:	output "<li>${element}</li>"%></ul>
	     <p>I hope that you would like Brail</p>	
	</body>
</html>
]]></programlisting>
			<para>
				The output of this program (assuming list is (1,2,3) and
				title is "Demo" ) would be:
			</para>
			<programlisting lang="html"><![CDATA[
<html>   
	<head>        
		<title>Demo</title>   
	</head>    
	<body>        
     <p>The following items are in the list:</p> 
     <ul><li>1</li><li>2</li><li>3</li></ul>
	</body>
</html>
]]></programlisting>
			<para>And the rendered HTML will look like this:</para>
			<programlisting lang="html"><![CDATA[
----
The following items are in the list:	
* 1
* 2
* 3
-----
]]></programlisting>
		</section>
	</section>
	<section>
		<title>Principal of Least Surprise</title>
		<para>
			On general, since NVelocity is the older view engine for
			now, I have tried to copy as much behavior as possible from
			NVelocityViewEngine. If you've a question about how Brail
			works, you can usually rely on the NVelocity behavior. If
			you find something different, that is probably a bug, so
			tell us about it.
		</para>
	</section>

	<section>
		<title>Configuration</title>
		<para>
			The default configuration should suffice for most cases, but
			if you want to change the configuration, you can do so by
			adding a configuration section handler to the web.config
			file:
		</para>
		<programlisting lang="html"><![CDATA[
<configSections>
  <section name="Brail" type="Brail.BrailConfigurationSection, Brail" />
</configSections>]]></programlisting>
		<para>Here is the default configuration for Brail:</para>
		<programlisting lang="html"><![CDATA[<Brail
	debug="false"
	saveToDisk="false"
	saveDirectory="Brail_Generated_Code"
	batch="true"
	commonScriptsDirectory="CommonScripts">

	<reference assembly="My.Assembly.Name"/>
	<import  namespace="My.Assembly.Name"/>
</Brail>
]]></programlisting>
		<informaltable>
			<tgroup cols="4">
				<colspec colnum="1" colname="col1" />
				<colspec colnum="2" colname="col2" />
				<colspec colnum="3" colname="col3" />
				<colspec colnum="4" colname="col4" />
				<thead>
					<row>
						<entry namest="col1" nameend="col2">
							Option:
						</entry>
						<entry>Default Value:</entry>
						<entry>Possible values:</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>debug</entry>
						<entry>Generate debug or retail code</entry>
						<entry>false</entry>
						<entry>
							<para>true - generate debug code</para>
							<para>false - generate retial code</para>
						</entry>
					</row>
					<row>
						<entry>saveToDisk</entry>
						<entry>
							Save the generated assemblies to disk -
							useful if you want to know what is going on
							behind the scenes.
						</entry>
						<entry>false</entry>
						<entry>
							<para>true - save assemblies to disk</para>
							<para>false - use entirely in memory</para>
						</entry>
					</row>
					<row>
						<entry>saveDirectory</entry>
						<entry>
							<para>
								The directory to save the generated
								assemblies to.
							</para>
							<para>
								The path can be relative or absolute, if
								relative, the default ASP.Net bin path
								will be used.
							</para>
							<para>
								If the directory does not exist, it will
								be created.
							</para>
						</entry>
						<entry>"Brail_Generated_Code"</entry>
						<entry>Any valid path</entry>
					</row>
					<row>
						<entry>batch</entry>
						<entry>
							<para>
								Batch compilation, compile all the
								scripts in one folder to a single
								assembly.
							</para>
							<para>This does not work recursively.</para>
						</entry>
						<entry>true</entry>
						<entry>
							<para>
								true - all scripts in a folder will be
								compiled to a single assembly
							</para>
							<para>
								false - each script will be compiled to
								its own assembly
							</para>
						</entry>
					</row>
					<row>
						<entry>commonScriptsDirectory</entry>
						<entry>
							<para>
								The directory where all the common
								scripts are. This can be a relative or
								absolute path, if relative, the Views
								directory of the application will be
								used as the base.
							</para>
							<para>
								If the directory does not exist, it will
								<emphasis>not</emphasis>
								be created.
							</para>
						</entry>
						<entry>"CommonScripts"</entry>
						<entry>Any valid path</entry>
					</row>
					<row>
						<entry>
							reference element, assembly attribute
						</entry>
						<entry>
							This tells Brails that all your scripts
							should reference the specified assembly or
							assemblies. This allows strong typing in the
							views and avoids the cost of reflection.
						</entry>
						<entry>none</entry>
						<entry>
							The assembly attribute must contain a valid
							assembly name that is reachable to the
							application by using
							<literal>Assembly.Load()</literal>
							. Usually this means that it's located in
							the
							<literal>bin</literal>
							directory of the application.
						</entry>
					</row>
					<row>
						<entry>
							import element, namespace attribute
						</entry>
						<entry>
							This tells Brails that all your scripts
							should import the specified namespace or
							namespaces. This allows shorter naming in
							the script.
						</entry>
						<entry>none</entry>
						<entry>Any valid namespace</entry>
					</row>
				</tbody>
			</tgroup>
		</informaltable>
	</section>
	<section>
		<title>Code Separators</title>
		<para>
			Brail supports two code separators &lt;% %&gt; and
			&lt;?brail ?&gt;, I find that &lt;% %&gt; is usually easier
			to type, but &lt;?brail ?&gt; allows you to have valid XML
			in the views, which is important for some use cases.
			Anything outside a &lt;?brail ?&gt; or &lt;% %&gt; is sent
			to the output. ${user.Id} can be used for string
			interpolation.
		</para>
		<warning>
			<para>
				The code separator types cannot be mixed. Only one type
				of separators must be used per file.
			</para>
		</warning>
	</section>
	<section>
		<title>Output Methods</title>
		<para>
			Since most of the time you will want to slice and dice text
			to serve the client, you need some special tools to aid you
			in doing this. Output methods* are methods that are
			decorated by [Html] / [Raw] / [MarkDown] attributes. An
			output method return value is transformed according to the
			specified attribute that has been set on it, for instance,
			consider the [Html] attribute:
		</para>
		<programlisting lang="html"><![CDATA[
<%
[Html]
def HtmlMethod():
	return "Some text that will be <html> encoded"
end
%>
${HtmlMethod()}
]]></programlisting>
		<para>The output of the above script would be:</para>
		<programlisting><![CDATA[Some text that will be <html> encoded]]></programlisting>
		<para>
			The output of a method with [Raw] attribute is the same as
			it would've without it (it's supplied as a NullObject for
			the common case) but the output of the MarkDown attribute is
			pretty interesting. Here is the code:
		</para>
		<programlisting lang="html"><![CDATA[
<%
[MarkDown]
def MarkDownOutput():
	return "[Ayende Rahien](http://www.ayende.com/), __Rahien__."
end
%>
${MarkDownOutput()}
]]></programlisting>
		<para>And here is the output:</para>
		<programlisting lang="html"><![CDATA[<p><a href="http://www.ayende.com/">Ayende Rahien</a>, <strong>Rahien</strong>.</p>]]></programlisting>
		<para>
			<ulink url="http://daringfireball.net/projects/markdown/">
				Markdown
			</ulink>
			is very interesting and I suggest you read about its usage.
		</para>
	</section>
	<section>
		<title>Using Variables</title>
		<para>
			A controller can send the view variables, and the
			<ulink url="http://boo.codehaus.org">Boo</ulink>
			script can reference them very easily:
		</para>
		<programlisting lang="html"><![CDATA[
My name is ${name}
<ul>
<%
for element in list:
    output "<li>${element}</li>"
end
%>
</ul>
]]></programlisting>
		<para>
			Brail has all the normal control statements of
			<ulink url="http://boo.codehaus.org">Boo</ulink>
			, which allows for very easy way to handle such things as:
		</para>
		<programlisting lang="html"><![CDATA[<% output AdminMenu(user) if user.IsAdministrator %>]]></programlisting>
		<para>
			This will send the menu to the user only if he is
			administrator.
		</para>
		<para>
			One thing to note about this is that we are taking the
			variable name and trying to find a matching variable in the
			property bag that the controller has passed. If the variable
			does not exist, this will cause an error, so pay attention
			to that. You can test that a variable exists by calling the
			IsDefined() method.
		</para>
		<programlisting lang="html"><![CDATA[
<%
if IsDefined("error"):
	output error
end
%>
]]></programlisting>
		<para>
			Or, using the much clearer syntax of "?variable" name:
		</para>
		<programlisting lang="html"><![CDATA[
<%
output ?error
%>
]]></programlisting>
		<para>
			The syntax of "?variable" name will return an IgnoreNull
			proxy, which can be safely used for null propagation, like
			this:
		</para>
		<programlisting lang="html"><![CDATA[
<%
# will output an empty string, and not throw a null reference exception
output ?error.Notes.Count
%>
]]></programlisting>
		<para>
			This feature can make it easier to work with optional
			parameters, and possible null properties. Do note that it
			will work only if you get the parameter from the property
			bag using the "?variableName" syntax. You can also use this
			using string interpolation, like this:
		</para>
		<programlisting lang="html"><![CDATA[
Simple string interpolation: ${?error}
And a more complex example: ${?error.Notes.Count}
]]></programlisting>
		<para>
			In both cases, if the error variable does not exists,
			nothing will be written to the output.
		</para>
	</section>
	<section>
		<title>Sub Views</title>
		<para>
			There are many reasons that you may want to use a sub view
			in your views and there are several ways to do that in
			Brail. The first one is to simply use the common
			functionality. This gives a good solution in most cases (see
			below for a more detailed discussion of common scripts).
		</para>
		<para>
			The other ways is to use a true sub view, in Brail, you do
			that using the OutputSubView() method:
		</para>
		<programlisting lang="html"><![CDATA[
Some html
<?brail OutputSubView("/home/menu")?>
<br/>some more html
]]></programlisting>
		<para>You need to pay attention to two things here:</para>
		<para>The rules for finding the sub view are as followed:</para>
		<itemizedlist>
			<listitem>
				<para>
					If the sub view start with a '/' : then the sub view
					is found using the same algorithm you use for
					RenderView()
				</para>
			</listitem>
			<listitem>
				<para>
					If the sub view doesn't start with a '/' : the sub
					view is searched starting from the ''current
					script'' directory.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			A sub view inherit all the properties from its parent view,
			so you have access to anything that you want there.
		</para>
		<para>
			You can also call a sub view with parameters, like you would
			call a function, you do it like this:
		</para>
		<programlisting lang="html"><![CDATA[<?brail OutputSubView("/home/menu", { "var": value, "second_var": another_value } ) ?>]]></programlisting>
		<para>
			Pay attention to the brackets, what we have here is a
			dictionary that is passed to the /home/menu view. From the
			sub view itself, you can just access the variables normally.
			This variables, however, are not inherited from views to sub
			views.
		</para>
	</section>
	<section>
		<title>Importing Content From Files</title>
		<para>
			Occasionally a need will arise to include a file "as-is" in
			the output, this may be a script file, or a common html
			code, and the point is not to interpret it, but simply send
			it to the user. In order to do that, you simply need to do
			this:
		</para>
		<programlisting lang="html"><![CDATA[${System.IO.File.OpenText("some-file.js").ReadToEnd()}]]></programlisting>
		<para>
			Of course, this is quite a bit to write, so you can just put
			an import at the top of the file and then call the method
			without the namespace:
		</para>
		<programlisting lang="html"><![CDATA[
<%
import System.IO
%>
${File.OpenText("some-file.js").ReadToEnd()}
]]></programlisting>
	</section>
	<section label="">
		<title>Principle of Least Surprise</title>
		<para>
			On general, since NVelocity is the older view engine for
			now, I have tried to copy as much behavior as possible from
			NVelocityViewEngine. If you've a question about how Brail
			works, you can usually rely on the NVelocity behavior. If
			you find something different, that is probably a bug, so
			tell us about it.
		</para>
	</section>

	<section>
		<title>Common Scripts</title>
		<para>
			In many cases, you'll have common functionality that you'll
			want to share among all views. Just drop the file in the
			CommonScripts directory - (most often, this means that you
			will drop your common functionality to Views\CommonScripts)
			- and they will be accessible to any script under the site.
		</para>
		<note>
			<para>
				The language used to write the common scripts is the
				<emphasis>white space agnostic</emphasis>
				deriative of Boo, and not the normal one. This is done
				so you wouldn't have white spacing sensitivity in one
				place and not in the other.
			</para>
		</note>
		<note>
			<para>
				The common scripts are normal Boo scripts and get none
				of the special treatment that the view scripts gets. An
				error in compiling one of the common scripts would cause
				the
				<emphasis>entire</emphasis>
				application to stop.
			</para>
		</note>
		<para>
			Here is an example of a script that sits on the
			CommonScripts and how to access it from a view:
		</para>
		<para>
			<literal>Views\CommonScripts\SayHello.boo</literal>
			- The common script
		</para>
		<programlisting lang="cs"><![CDATA[
def SayHello(name as string):
	return "Hello, ${name}"
end
]]></programlisting>
		<para>
			<literal>Views\Home\HelloFromCommon.boo</literal>
			- The view using the common functionality
		</para>
		<programlisting lang="html"><![CDATA[
<%
output SayHello("Ayende")
%>
]]></programlisting>
		<para>The output from the script:</para>
		<programlisting lang="html"><![CDATA[Hello, Ayende]]></programlisting>
	</section>
	<section>
		<title>Symbols and Dictionaries</title>
		<para>
			Quite often, you need to pass a string to a method, and it
			can get quite cumbersome to understand when you have several
			such parameters. Brail support the notion of symbols, which
			allows to use an identifier when you need to pass a string.
			A symbol is recognized by a preceding '@' character, so you
			can use this syntax:
		</para>
		<programlisting lang="html"><![CDATA[
<%
output SayHello( @Ayende )
%>
]]></programlisting>
		<para>
			And it will work exactly as if you called SayHello( "Ayende"
			). The difference is more noticable when you take into
			account methods that take components or dictionary
			parameters, such as this example:
		</para>
		<programlisting lang="html"><![CDATA[
<%
component Grid, {@source: users, @columns: [@Id, @Name] }
%>
]]></programlisting>
		<para>
			Using a symbol allows a much nicer syntax than using the
			string alternative:
		</para>
		<programlisting lang="html"><![CDATA[
<%
component Grid, {"source: users, "columns": ["Id", "Name"] }
%>
]]></programlisting>
	</section>
	<section>
		<title>Layouts</title>
		<para>
			Using layouts is very easy, it is just a normal script that
			outputs ChildOutput property somewhere, here is an example:
		</para>
		<programlisting lang="html"><![CDATA[
Header
${ChildOutput}
Footer
]]></programlisting>
	</section>
	<section>
		<title>Performance</title>

		<para>
			If you want to use Brail for 10 million transactions a day,
			I would suggest measuring first, but in general, it should
			be good for most of what you throw at it.
		</para>
		<para>
			Batch compilation should reduce compile time and memory
			size. The code is
			<emphasis>not</emphasis>
			interpreted, it's statically compiled (very similar to how
			ASP.Net does it) and run whenever a request comes in.
			Currently there is no further reason to complicate the code
			until someone actually needs it. The second time that a
			request comes in for a page, it's already compiled and can
			immediately serve the request.
		</para>
		<para>
			A change in a single file will cause a separate assembly to
			be loaded, and all future requests will go the the new
			assembly immediately. Be aware that a large number of
			changes in an application will cause an assembly leak, since
			the assemblies cannot be unloaded until the AppDomain is
			unloaded. This isn't a problem in production scenarios, and
			on a development machine, the usual IIS application resets
			should take care of it.
		</para>
		<para>
			If you think that reflection kills your performance, make
			sure to reference your relevant assemblies and use casting
			to the appropriate types when applicable. Another option
			would be to improve dynamic dispatch, but that would wait
			until there is a true need for it.
		</para>
		<section>
			<title>Referencing Assemblies</title>
			<para>Consider the following this code:</para>
			<programlisting lang="html"><![CDATA[
<%
for user in users:
	output "<p>${user.Name} - ${user.Email}</p>"
end
%>
]]></programlisting>
			<para>
				Looks simple, right? The problem is that Brail doesn't
				really know what
				<literal>user</literal>
				is, so it uses reflection to get the values of the
				<literal>Name</literal>
				and
				<literal>Email</literal>
				properties. This is, of course, quite expensive in
				performance terms. What is the solution? You need to
				tell Brail to add a reference to the assembly where
				<literal>User</literal>
				is defined. You can do that by adding this line to your
				<literal>web.config</literal>
				file (see the full configuration section below for more
				details).
			</para>
			<programlisting lang="html"><![CDATA[
<Brail>
     <reference assembly="assembly.with.user.object" />
</Brail>
]]></programlisting>
			<para>And then, in your view code, you write:</para>
			<programlisting lang="html"><![CDATA[
<%
import My.Models
%>
<!-- lots of html code ->
<%
for user as User in users:
	output "<p>${user.Name} - ${user.Email}</p>"
end
%>
]]></programlisting>
			<para>
				You can also use this out side of loops, in order to get
				strong typing (and the assoicated performance benefits):
				<programlisting lang="html"><![CDATA[
<%
import My.Models
%>
<!-- lots of html code ->
<%
# define a parameter called user of type User
user as User = GetParameter("user")
# now it uses strong typing, instead of reflection
output "<p>${user.Name} - ${user.Email}</p>"
%>
]]></programlisting>
			</para>
			<para>
				With this simple change, you've completely eliminated
				the use of reflection and probably increased by a fair
				margin your application performance. However, because it
				significantly increases the complexity of developing the
				views, it is not really the recommended approach. If you
				run into a situation where the cost of reflection in the
				views is a significant one, there are other options,
				which involve improving dynamic dispatch inside of
				Brail, bringing you the benefits without the cost. This
				is not implemented currently, because so far we have not
				run into a situation where this was a problem that
				warranted the additional complexity.
			</para>
			<note>
				<para>
					Beyond making the view code more complex, this can
					affect the ability to use some of the nicer
					abilities on Brail, such as ignoring null references
					using the IgnorNull proxy.
				</para>
			</note>
		</section>
		<section>
			<title>Auto Imports</title>
			<para>
				As you can imagine, it can get tiresome to specify the
				default imports all over the place, Brail supports
				automatic imports from the configuration. All you need
				to do is specify the following in the
				<literal>web.config</literal>
				file:
			</para>
			<programlisting lang="html"><![CDATA[
<Brail>
     	<import namespace="My.Models"/>
</Brail>
]]></programlisting>
			<para>And it will be added for you by Brail.</para>
		</section>
	</section>
	<section>
		<title>ViewComponent Support</title>
		<para>
			Brail supports the following syntax for ViewComponents:
		</para>
		<programlisting lang="html"><![CDATA[
<%
component MyViewComponent
%>
]]></programlisting>
		<para>
			The above will call
			<literal>MyViewComponent</literal>
			and send any output from the component to the browser.
		</para>
		<para>
			You can also use view components with arguments. Those
			arguments are passed via a dictionary (Hash table), like
			this:
		</para>
		<programlisting lang="html"><![CDATA[
<%
component MyViewComponentWithParams, {"arg" : "value" }
%>
]]></programlisting>
		<para>
			If you want to pass a body to the component, just use the
			normal colon + indnet to do so:
		</para>
		<programlisting lang="html"><![CDATA[
<% component MyViewComponentWithBody: %>
html content that will be sent to the user if the component will call the RenderBody() method
<% end %>
]]></programlisting>
		<para>
			The contents of a component is evaluated when you call
			<literal>RenderBody</literal>
			, so if you will call
			<literal>RenderBody</literal>
			multiple times, you will send the output of the component's
			body multiple times as well.
		</para>
		<para>
			You can also use sections in Brail. Sections are what a way
			to pass templates to the component in a fine grained manner.
			Here is a simple example:
		</para>
		<programlisting lang="html"><![CDATA[
<% 
component Grid:
	section Header:
	%>
		<th>Id</th>
		<th>Name</th>
	<%
	end
	section Item:
	%>
		<td>${item.Id}</td>
		<td>${item.Name}</td>
	<%
	end
end %>
]]></programlisting>
	</section>
	<section>
		<title>Troubleshooting</title>
		<para>
			Brail will throw an exception for any compilation errors,
			which will include the reason for the error as well as the
			transformed source code that caused the error, you can use
			that in order to find out what went wrong.
		</para>
		<para>
			One thing to be aware of with batch compilation is that if
			one of your scripts has an error, it will cause the entire
			batch to fail. Each script in the directory will first try
			the batch option, and when that fails, it will compile
			itself as a stand-alone assembly. This can be bad for
			performance if there are a lot of scripts in a directory.
			However, a second request for such a script would be served
			from memory, so it's not too bad.
		</para>
		<para>
			While it
			<emphasis>should</emphasis>
			be possible to debug the views scripts (add
			<literal>System.Diagnostics.Debugger.Break()</literal>
			instead of a breakpoint), I don't recommend it. There is a
			quite a bit of compiler magic behind
			<ulink url="http://boo.codehaus.org">Boo</ulink>
			as it is, and Brail does its fair share as well. It's likely
			that you won't have a good experience.
		</para>
	</section>
	<section>
		<title>Code Separators</title>

		<para></para>
	</section>
	<section>
		<title>How Brail Works</title>
		<para>
			First of all let's understand where Brail lives. Brail is a
			View Engine for the Castle MonoRail web development
			framework. MonoRail is MVC framework for ASP.Net that allows
			true Separation of Concerns between your business logic and
			your UI code.
		</para>
		<para>
			Brail comes into play when it's time to write your UI code,
			the idea is that instead of using a templating framework,
			like NVelocity or StringTemplate, you can use a bona fide
			programming language with all the benefits that this
			implies. The down side of this approach is that programming
			languages usually have very strict rules about how you can
			write code and that is usually the exact opposite of what
			you want when you write a web page. You want a language that
			wouldn't get in your way. This is where Brail comes into
			play.
		</para>
		<para>
			Brail is based on Boo, a programming language for the .Net
			Framework which has a very unorthodox view of the place of
			the user in the language design. Boo allows you to plug your
			own steps into the compiler pipeline, rip out whatever you
			don't like, put in things that you want, etc. This means
			that it packs a pretty punch when you need it. The options
			are nearly limitless. But enough raving about Boo, it is
			Brail that you are interested in. What Brail does is to
			allow you to write your web pages in Boo, in a very relaxed
			and free way. After you write the code, Brail takes over and
			transforms it to allow you to run this code. The Brail
			syntax and options are documented, so we assume that you are
			already familiar with it.
		</para>
		<para>
			We need to understand what MonoRail does when it receive a
			request:
		</para>
		<para>
			<itemizedlist>
				<listitem>
					<para>
						The user's browser sends a request to the
						server: GET: /admin/users/list.rails
					</para>
				</listitem>
				<listitem>
					<para>
						The ASP.Net runtime passes the request to
						MonoRail's ProcessEngine, which loads the
						appropriate controller and after the controller
						has finished running, it will call to the
						appropriate view.
					</para>
				</listitem>
				<listitem>
					<para>
						MonoRail's ProcessEngine calls to Brail passing
						the current context, the controller and a
						template name which will usually will look like
						this: "admin/users/list"
					</para>
				</listitem>
				<listitem>
					<para>
						Brail processes the request and writes the
						results back to the user.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<section>
			<title>Processing Requests</title>
			<para>
				MonoRail receives a request, calls the appropriate
				controller and then calls to the view engine with the
				current context, the controller and the view that needs
				to be displayed. Brail then takes over and does the
				following:
			</para>
			<para>
				<itemizedlist>
					<listitem>
						<para>
							Check if the controller has defined a layout
							and if it has, pipe the view's output
							through the layout's output. (The layout is
							compiled the same way a view is)
						</para>
					</listitem>
					<listitem>
						<para>
							Get the compiled version of a view script
							by:
							<itemizedlist>
								<listitem>
									<para>
										Checking if the script is
										already in the cache. The cache
										is a hash table ["Full file name
										of view" : compiled type of the
										view]
									</para>
								</listitem>
								<listitem>
									<para>
										If the script is already in the
										cache but the type is null this
										means that the view has changed,
										so we compile just this script
										again.
									</para>
								</listitem>
								<listitem>
									<para>
										Instantiate the type and run the
										instance, which will send the
										script output to the user.
									</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				A few things about changes in the views: Brail currently
				allows instantaneous replacement of views, layout and
				common scripts by watching over the Views directory and
				recompiling the file when necessary, since this is a
				developer only feature, I'm
				<emphasis>not</emphasis>
				worrying too much about efficiency / memory. I'm just
				invalidating the cache entry or recompiles the common
				scripts. Be aware that making a change to the Common
				Scripts would invalidate all the compiled views &amp;
				layouts in memory and they would all have to be compiled
				again. This is done since you can't replace an assembly
				reference in memory.
			</para>
			<para>
				The interesting stuff is most happening when Brail is
				compiling a script. For reference, Brail usually will
				try to compile all the scripts in a directory (but does
				not recurse to the child directories) in one go, since
				this is more efficient in regard to speed / memory
				issues. Occasionally it will compile a script by itself,
				usually when it has been changed after its directory has
				been compiled or if the default configuration has been
				changed. There isn't much difference between compiling a
				single file and compiling a bunch of them, so I'm just
				going to ignore that right now and concentrate on
				compiling a single script. Brail's scripts are actually
				a Boo file that is being transformed by custom steps
				that plug into the Boo compiler.
			</para>
		</section>
		<section>
			<title>Compiling Scripts</title>
			<para>
				Here is what happens when Brail needs to compile a
				script:
			</para>
			<para>
				Creating an instance of BooCompiler, and telling if to
				compile to memory or to file (configuration option).

				<itemizedlist>
					<listitem>
						<para>
							Adding a reference to the following
							assemblies: Brail,
							Castle.MonoRail.Framework, the compiled
							Common Script assembly and any assembly that
							the user referenced in the configuration
							file.
						</para>
					</listitem>
					<listitem>
						<para>
							Adding imports that were defined in the
							configuration
						</para>
					</listitem>
					<listitem>
						<para>
							Run a very simple pre processor on the file,
							to convert file with &lt;% %&gt; or
							&lt;?brail ?&gt; to a valid boo script.
						</para>
					</listitem>
					<listitem>
						<para>
							Remove the default Boo's namespace (this is
							done because common names such as list, date
							were introduced including the default
							namespace and that meant that you couldn't
							use that as a parameter to the view.
						</para>
					</listitem>
					<listitem>
						<para>
							Replace any variable reference that has
							unknown source with a call to
							GetParameter(variableName) which would use
							the controller's PropertyBag to get it.
							GetParameter() throws if it can't find a
							valid parameter, by the way. The reasoning
							is that this way you won't get null
							reference exceptions if you are trying to do
							something like: date.ToString("dd/mm/yyyy")
							and the controller didn't pass the date.
							Since debugging scripts is a pain, this
							gives you a much clearer message.
						</para>
					</listitem>
					<listitem>
						<para>
							Then the real transformation begins. Any
							Brail script is turned into a subclass of
							the BrailBase class, which provides basic
							services to the script and allow the engine
							to output the results to the user. What is
							happening is that any "free" code, code that
							isn't in a class / method is moved to a
							Run() method on the subclass. Any methods
							are moved to the subclass, so they are
							accessible from the Run() method. Anything
							else is simply compiled normally.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				When Brail receive a request for a view it looks it up
				as describe above (from cache/compiled, etc). A new
				instance of the view is created and its Run() method is
				called. All the output from the script is sent to the
				user (directly or via the layout wrapping it.)
			</para>
		</section>
		<section>
			<title>BrailBase Class</title>
			<para>
				The BrailBase class has several useful method and
				properties:
			</para>
			<para>
				<itemizedlist>
					<listitem>
						<para>
							ChildOutput - Layouts are scripts that are
							using their ChildOutput property to wrap
							their output around the child output. This
							works as follows, a layout is created, and
							its ChildOutput is set to a view's output,
							the view is then run. After the view run,
							the layout is run and has access to the
							view's layout.
						</para>
					</listitem>

					<listitem>
						<para>
							IsDefined(parameterName) - Check if a
							parameter has been passed, this allows you
							to bypass GetParameter() throwing if nothing
							has been passed.
						</para>
					</listitem>

					<listitem>
						<para>
							OutputSubView() - Output another view.
						</para>
					</listitem>
				</itemizedlist>
				You can check the source here:
				https://svn.castleproject.org/svn/castle/trunk/MonoRail/Castle.MonoRail.Views.Brail/BrailBase.cs
				for the full details
			</para>
		</section>
	</section>
</section>