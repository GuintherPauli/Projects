<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../../toolchain/docbook-xml/docbookx.dtd">
<chapter id="getting_started">
	<title id="getting_started.title">Getting Started</title>
	<section>
		<title>Introduction</title>
		<para>
			<emphasis>Castle MonoRail</emphasis>
			greatly simplifies web development. The Getting Started
			chapter is going to show you how common tasks are handled
			and how MonoRail performs most of the repetitive work in web
			development on your behalf.
		</para>
		<para>
			Among other things you will learn
			<itemizedlist>
				<listitem>
					<para>
						About
						<emphasis>controllers</emphasis>
						and
						<emphasis>views</emphasis>
						and how they relate to each other
					</para>
				</listitem>
				<listitem>
					<para>
						How to use
						<emphasis>layouts</emphasis>
						and
						<emphasis>rescues</emphasis>
					</para>
				</listitem>
				<listitem>
					<para>
						How to use the
						<classname>SmartDispatcherController</classname>
						and the DataBinder
					</para>
				</listitem>
				<listitem>
					<para>How to easily create a CRUD page</para>
				</listitem>
				<listitem>
					<para>
						How Castle ActiveRecord integrates nicely with
						MonoRail
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			Although it should go without saying, you are not obliged to
			use ActiveRecord as your primary data access framework with
			MonoRail - you can use whatever approach to performing data
			access you like. That being said if you do use ActiveRecord,
			there are some provided integrations that might save you
			some time. Regardless, the framework provided allows you to
			develop similar integration for your preferred data access
			approach should you choose to do so.
		</para>
		<para>
			You can also download the complete example:

			<note>
				<para>
					You can also download the complete example
					demonstrating the concepts from
					<ulink
						url="/samples/MonoRail.GettingStartedSampleVS2005.zip">
						here.
					</ulink>
				</para>
			</note>
		</para>
	</section>
	<section>
		<title>Requirements</title>
		<para>
			For the purposes of this chapter we will assume that you
			have Castle Project assemblies present on your local
			machine. If you don't, we encourage you to download the
			<ulink
				url="http://www.castleproject.org/castle/download.html">
				MSI installer distribution
			</ulink>
			as it automatically installs all the required assemblies in
			the Global Assembly Cache, making them visible to Visual
			Studio.
		</para>
		<para>
			During the course of this chapter will be using a database.
			For simplicity's sake all discussion surrounding database
			configuration will refer ot MSSQL Server 2000 however if you
			prefer to use another database you can select any other
			database supported by NHibernate and will find very little
			deviation from the text in this chapter.
		</para>
	</section>
	<section>
		<title>Creating the Project Skeleton</title>
		<para>
			As mentioned in the
			<link
				linkend="introduction.convention_over_configuration">
				Introduction
			</link>
			MonoRail tends to favour convention over configuration and
			when creating a project structure we encourage you to use a
			project structure similar to the following to remain in line
			with these conventions.
		</para>

		<mediaobject>
			<imageobject>
				<imagedata fileref="images/gs_folders.png" />
			</imageobject>
		</mediaobject>

		<!-- TODO: Further explanation as to *why* would be nice here. -->

		<para>
			The following sections show you how to create this structure
			manually or by using the MonoRail project wizard and will
			further explain the reasoning behind its use.
		</para>
		<section>
			<title>Using the MonoRail Project Wizard</title>
			<para>
				If you have installed Castle Project using the MSI
				installer you are likely to have the Visual Studio
				Integration installed as well. Should that be the case
				the easiest way to create a new MonoRail project is the
				use the Castle MonoRail Project Wizard.
			</para>
			<warning>
				<para>
					The Castle MonoRail Project template described below
					requires that your Visual Studio installation has
					Web Project support installed. Visual Studio 2005
					does not come with Web Project support out of the
					box, however there are two options for adding Web
					Project support to Visual Studio; you can install
					the
					<ulink
						url="http://msdn2.microsoft.com/en-us/asp.net/aa336618.aspx">
						Web Project support
					</ulink>
					add in or alternately you can ensure your Visual
					Studio installation is upgraded to
					<ulink
						url="http://msdn2.microsoft.com/en-us/vstudio/bb265237.aspx">
						Visual Studio 2005 Service Pack 1
					</ulink>
					or later.
				</para>
			</warning>
			<para>
				To create a MonoRail project using the wizard just
				perform the following simple steps:
			</para>
			<orderedlist>
				<listitem>
					<para>
						Open Visual Studio and go to
						<menuchoice>
							<guimenu>New</guimenu>
							<guimenuitem>Project</guimenuitem>
						</menuchoice>
					</para>
					<para>
						Under Visual Studio 2005 you will see the
						following dialog:
					</para>
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="images/gs_wizard2005.png" />
						</imageobject>
					</mediaobject>
				</listitem>
				<listitem>
					<para>
						Select the
						<emphasis>Castle MonoRail Project</emphasis>
						template, enter
						<userinput>GettingStartedSample</userinput>
						as the name for your new project then click the
						<guibutton>OK</guibutton>
						button.
					</para>
				</listitem>
				<listitem>
					<para>
						When the wizard starts select the
						<option>NVelocity View Engine</option>
						from the list of View Engines and click the
						<guibutton>Next</guibutton>
						button.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="images/gs_wizard2005_1.png" />
							</imageobject>
						</mediaobject>
					</para>
					<note>
						<para>
							Do not enable Windsor Integration or Routing
							at this stage.
						</para>
					</note>
				</listitem>
				<listitem>
					<para>
						The next step in the wizard will offer the
						option to create a Test project where unit tests
						for your new MonoRail application can be
						created. Ensure the checkbox to create the test
						project is checked then click the
						<guibutton>Finish</guibutton>
						button.
					</para>
				</listitem>
			</orderedlist>
			<para>
				Once all of the above steps have been completed the
				wizard will create the solution, the web project and the
				test project and will set up all the basic configuration
				required for MonoRail to run.
			</para>
		</section>
		<section>
			<title>Creating the Project Manually</title>
			<para>
				If you haven't installed the Visual Studio integration
				or would prefer not to use the project wizard and
				instead would rather set up the project structure by
				hand you can follow the steps outlined below.
			</para>
			<section>
				<title>Create the Project</title>
				<para>
					Create an
					<emphasis>ASP.Net Web Application</emphasis>
					project in Visual Studio 2005. If the
					<emphasis>ASP.Net Web Application</emphasis>
					template is not present in your Visual Studio
					installation you can create a
					<emphasis>Class Library</emphasis>
					project instead.
				</para>
				<para>
					Name the new project
					<userinput>GettingStartedSample</userinput>
					then click the
					<guibutton>OK</guibutton>
					button.
				</para>
			</section>
			<section>
				<title>Reference the MonoRail Assemblies</title>
				<para>
					To make the new project into a MonoRail application
					you will need to add references to the MonoRail
					assemblies. For the purposes of our sample
					application the assemblies listed below will be
					required.
				</para>
				<para>
					<informaltable>
						<tgroup cols='2' align='left' colsep='1'
							rowsep='1'>
							<colspec colname='c1' />
							<colspec colname='c2' />
							<thead>
								<row>
									<entry>Assembly</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										Castle.MonoRail.Framework.dll
									</entry>
									<entry>
										Contains the classes that make
										up the core of the MonoRail
										framework.
									</entry>
								</row>
								<row>
									<entry>
										Castle.MonoRail.Framework.Views.NVelocity.dll
									</entry>
									<entry>
										Defines an NVelocity view engine
										plugin that will be used for
										handling views. This will in
										turn use the NVelocity rendering
										engine.
									</entry>
								</row>
								<row>
									<entry>
										Castle.Components.Validator.dll
									</entry>
									<entry>
										Provides a lightweight
										validation infrastructure
										created by Castle.
									</entry>
								</row>
								<row>
									<entry>
										Castle.Components.Binder.dll
									</entry>
									<entry>
										Contains the logic for the
										databinding that is used in
										MonoRail.
									</entry>
								</row>
								<row>
									<entry>
										Castle.Components.Common.EmailSender.dll
									</entry>
									<entry>
										Defines the interface for
										components that send email.
									</entry>
								</row>
								<row>
									<entry>
										Castle.Components.Common.EmailSender.SmtpEmailSender.dll
									</entry>
									<entry>
										Provides an SMTP implementation
										of the EmailSender that will be
										responsible for sending email.
									</entry>
								</row>
								<row>
									<entry>Castle.Core.dll</entry>
									<entry>
										Core Castle class library
										containing functionality used by
										many projects, including
										MonoRail.
									</entry>
								</row>
								<row>
									<entry>NVelocity.dll</entry>
									<entry>
										The NVelocity template engine
										used for rendering NVelocity
										templates.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</para>
			</section>
			<section>
				<title>Create the Project Folders</title>
				<para>
					The next step is to create the following folders on
					the project. Again, this is just a convention we
					encourage you to follow - you may come up with a
					more suitable convention for your projects after you
					get used to the framework so this is no way
					mandatory.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/gs_solution.png" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section>
				<title>Configuration</title>
				<para>
					To configure the application to use MonoRail
					additional information needs to be added to the
					<filename>web.config</filename>
					file; you must register the MonoRail configuration
					handler, the MonoRail configuration section, an HTTP
					handler and an HTTP module. Each of these will be
					discussed further below.
				</para>
				<para>
					First, add the MonoRail configuration handler:
				</para>

				<programlisting language="xml"><![CDATA[
<configuration>
	<configSections>
		<section 
			name="monorail" 
			type="Castle.MonoRail.Framework.Configuration.MonoRailSectionHandler, Castle.MonoRail.Framework" />
	</configSections>
	
	...
]]></programlisting>
				<para>
					Next add the
					<code><![CDATA[<monorail>]]></code>
					configuration section.
				</para>
				<programlisting language="xml"><![CDATA[
	...
	
	<monorail>
		<controllers>
			<assembly>GettingStartedSample</assembly>
		</controllers>
		
		<viewEngines viewPathRoot="Views">
			<add type="Castle.MonoRail.Framework.Views.NVelocity.NVelocityViewEngine, Castle.MonoRail.Framework.Views.NVelocity" />
		</viewEngines>
	</monorail>
	
	...
]]></programlisting>
				<para>
					This is the section that will contain all the
					configuration that controls setting up and
					customizing the behavior of MonoRail itself. The
					elements included for our sample above are the
					<literal><![CDATA[<controllers>]]></literal>
					node that defines the list of assemblies that
					contain the controllers for the application and the
					<literal><![CDATA[<viewEngines>]]></literal>
					node the specifies the view engine that will handle
					rendering the view templates in the application.
					There are more configuration options available in
					the
					<link linkend="configuration"
						endterm="configuration.title" />
					chapter, however the elements above are sufficient
					for our sample application.
				</para>
				<para>
					It should be noted at this point that we have chosen
					the NVelocity view engine for rendering the views in
					our application.
					<application>NVelocity</application>
					is a very simple template engine that supports
					conditional statements, assignments, array creation,
					and iteration over collections that provides all the
					functionality you will generally need during the
					rendering of a view. You can learn more about
					<application>NVelocity</application>
					(and how we have improved it) on
					<ulink url="../../others/nvelocity/index.html">
						its page
					</ulink>
					.
				</para>
				<para>
					Next we will add a couple of HTTP Handlers under the
					<literal><![CDATA[<httpHandlers>]]></literal>
					node in the
					<literal><![CDATA[<system.web>]]></literal>
					section of the
					<filename>web.config</filename>
					.
				</para>
				<programlisting language="xml"><![CDATA[
...
	
	<system.web>
		<httpHandlers>
		
			<add 
				verb="*" 
				path="*.castle" 
				type="Castle.MonoRail.Framework.MonoRailHttpHandlerFactory, Castle.MonoRail.Framework" />
			
			<add 
				verb="*" 
				path="*.vm" 
				type="System.Web.HttpForbiddenHandler"/>
				
		</httpHandlers>
		
		...
-
]]></programlisting>
				<para>
					The first HTTP Handler is responsible for routing
					incoming requests to MonoRail based on their
					extension. The example above indicates that incoming
					requests ending in
					<literal>.castle</literal>
					should be handled by MonoRail. If you prefer another
					extension such as
					<literal>.rails</literal>
					you can simply change the value of the
					<literal>path</literal>
					attribute to your preferred value.
				</para>
				<para>
					The second handler is present as a security
					consideration. It is important to to be aware that
					if a file in a web folder is accessed from the
					outside world its contents will normally be sent
					directly to the calling browser. To prevent the
					source for your view files from being visible to the
					outside world an
					<classname>HttpForbiddenHandler</classname>
					needs to be configured for the file extension of any
					files you don't want want to be directly accessible.
					In this case, because we chose to use the NVelocity
					view engine and our view templates use the
					<literal>.vm</literal>
					extension this is the extension we have associated
					with the
					<classname>HttpForbiddenHandler</classname>
					.
				</para>
				<para>
					Finally you need to register the MonoRail HTTP
					module that handles incoming requests into the
					<literal><![CDATA[<httpModules>]]></literal>
					node, which is also found in the
					<literal><![CDATA[<system.web>]]></literal>
					section.
				</para>
				<programlisting language="xml"><![CDATA[
		...
		
		<httpModules>
			<add 
				name="monorail" 
				type="Castle.MonoRail.Framework.EngineContextModule, Castle.MonoRail.Framework" />
		</httpModules>
	</system.web>
	
</configuration>
]]></programlisting>
			</section>
		</section>
	</section>
	<section>
		<title>Controllers, Actions and Views</title>
		<para>
			For all MonoRail MVC applications the entry point for each
			request is the controller - this is the single largest
			deviation from the approach taken in Web Forms development
			where the entry point is the page itself. With MonoRail the
			controller is executed in response to a request where an
			action decides whether or not it should render a view and,
			if so, which one to render. As a result the controller has
			control over the application flow rather than the
			pages/views. This returns views back to their original role:
			to present information - nothing more and nothing less.
		</para>
		<para>
			It is important at this point to understand the relationship
			between the structure of the URL specified to access a
			resource and the controller. A common URL to a MonoRail web
			page might look like the following:
		</para>
		<para>
			<screen><![CDATA[
http://www.some-server.net/home/index.castle
|                         |    |     |      | 
+-------------------------+----+-----+------+
          ^                 ^     ^     ^
          |                 |     |     |
        Server              |     |     |
                            |     |     |
                      Controller  |     |
                                  |     |
                               Action   |
                                        |
                                    Extension
]]></screen>
		</para>
		<para>
			In the diagram above the extension
			<literal>.castle</literal>
			indicates that MonoRail should handle the request,
			<literal>home</literal>
			specifies the controller to use and
			<literal>index</literal>
			indicates that the
			<methodname>Index</methodname>
			method on the controller should be executed. Since MonoRail
			prefers convention over configuration the default behaviour
			is, by default, for the controller's class name to be the
			name of the controller found on the URL with the word
			<emphasis>Controller</emphasis>
			appended to the end, so if the controller name
			<literal>home</literal>
			is found in the URL the controller class used in response to
			this request will be the
			<classname>HomeController</classname>
			class.
		</para>
		<section>
			<title>Your First Controller</title>
			<para>
				It is now time to create your first controller. If you
				have used the wizard to create the project, a
				<classname>HomeController</classname>
				class will already have been created for you. If it is
				not already present you should create a new class named
				<classname>HomeController</classname>
				in the
				<filename>Controllers</filename>
				folder of your project.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_controller_1.png" />
					</imageobject>
				</mediaobject>
			</para>
			<para>
				Inside the
				<classname>HomeController</classname>
				class the following code should be present. If you have
				just created the class file yourself you should add the
				code now.
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Controllers
{
	using System;

	using Castle.MonoRail.Framework;

	[Layout("default"), Rescue("generalerror")]
	public class HomeController : SmartDispatcherController
	{
		public void Index()
		{
		}
	}
}
]]></programlisting>
		</section>
		<section>
			<title>The Index Action and View</title>
			<para>
				An
				<emphasis>action</emphasis>
				is a public non-static method exposed by a controller
				class. The controller shown in the previous section
				exposes just one action,
				<literal>Index</literal>
				which is empty, however due to MonoRail's convention
				over configuration approach the controller will render a
				specific view template by default.
			</para>
			<para>
				The view template chosen by MonoRail is affected by the
				view engine we chose during the configuration phase of
				the project. Since we chose to use the NVelocity view
				engine all of our view templates will end with the
				<literal>.vm</literal>
				extension.
			</para>
			<para>
				By default, the specific view template file chosen for
				rendering is based on the name of the action being
				executed and the folder in which the view template is
				located is based on the name of the controller handling
				the request.
			</para>
			<para>
				As a result the default view template chosen by the
				<methodname>Index</methodname>
				action on the
				<classname>HomeController</classname>
				will be
				<literal>index.vm</literal>
				located under the
				<filename>/views/home</filename>
				folder in the project.
			</para>
			<note>
				<para>
					This behavior can be overridden in several ways that
					are covered later in this guide.
				</para>
				<!-- TODO: Is it? -->
			</note>
			<para>
				If the view template
				<filename>index.vm</filename>
				does not yet exist in the
				<filename>/views/home</filename>
				folder of your project create it now.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_view_1.png" />
					</imageobject>
				</mediaobject>
			</para>
			<para>
				To illustrate a point we will make the content of the
				<literal>home.vm</literal>
				file nice and simple to start with. If the
				<literal>home.vm</literal>
				file does not contain the content below just copy and
				paste it in there.
			</para>
			<programlisting language="xml"><![CDATA[
<p>

Hello world from my first action.

</p>
]]></programlisting>
			<note>
				<para>
					You can make Visual Studio use the HTML editor for
					<literal>.vm</literal>
					files. Use the
					<guimenuitem>Open With...</guimenuitem>
					option from the context menu.
				</para>
			</note>
			<para>
				This is a fairly simple view. Note that in the view
				template we did not include the html or body tags. We
				will leave those to the
				<emphasis>layout</emphasis>
				to render, which we will cover next.
			</para>
		</section>
		<section>
			<title>Setting the Layout and Rescue</title>
			<para>
				When we created the
				<classname>HomeController</classname>
				you may have noticed the
				<classname>Layout</classname>
				and
				<classname>Rescue</classname>
				attributes were specified on the class.
			</para>
			<programlisting language="cs"><![CDATA[
[Layout("default"), Rescue("generalerror")]
public class HomeController : SmartDispatcherController
]]></programlisting>
			<para>
				These define the following:
				<itemizedlist>
					<listitem>
						<para>
							The
							<classname>Layout</classname>
							attribute indicates that every view rendered
							by this controller to should be wrapped in
							the content from the
							<filename>default.vm</filename>
							template in the
							<filename>/layouts</filename>
							folder of the project.
						</para>
					</listitem>
					<listitem>
						<para>
							The
							<classname>Rescue</classname>
							attribute tells MonoRail that if any
							unhandled exception is thrown by the an
							action on the
							<classname>HomeController</classname>
							a special
							<emphasis>rescue</emphasis>
							view template called
							<literal>generalerror.vm</literal>
							in the
							<filename>/rescues</filename>
							folder of the project should be rendered.
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</section>
		<section>
			<title>Creating the Layout</title>
			<para>
				A
				<emphasis>layout</emphasis>
				defines the outer content of a rendered view and has
				some similarities to a master page. Your project can
				have as many layouts as you like - the layout files
				simply need to be placed into the
				<filename>/layouts</filename>
				folder of the project.
			</para>
			<para>
				Our first layout is very simple, and should be saved as
				<filename>default.vm</filename>
				on the
				<filename>/layouts</filename>
				folder.
			</para>
			<programlisting language="xml"><![CDATA[
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
		<head>
			<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
			<title>Layout</title>
			<link rel="stylesheet" href="$siteRoot/Content/css/base.css" />
		</head>		
	<body>
	
	$childContent
		
	</body>
</html>
]]></programlisting>
			<para>
				At this point some explanation of the template above is
				in order.
			</para>
			<para>
				The
				<varname>$childContent</varname>
				variable defines where the content of the view being
				rendered will be included on the layout.
			</para>
			<para>
				The
				<varname>$siteRoot</varname>
				variable will represent the root of the application. If,
				for example, the web application is using a virtual
				directory it will be the name of the virtual directory.
				Under normal circumstances, however, it will evaluate to
				a simple
				<literal>/</literal>
				.
			</para>
		</section>
		<section>
			<title>Seeing the Results</title>
			<para>
				If you created the application with the wizard, just hit
				<menuchoice>
					<guimenu>Debug</guimenu>
					<guimenuitem>Start</guimenuitem>
				</menuchoice>
				or
				<keysym>F5</keysym>
				.
			</para>
			<para>
				On the browser, go to the application URL and enter the
				controller name and the action name plus the extension
				you have selected, eg.
				<literal>
					http://localhost:8081/home/index.castle
				</literal>
				.
			</para>
			<para>
				The browser should render the view content with the
				layout applied:
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_exec_1.png" />
					</imageobject>
				</mediaobject>
			</para>
			<para>
				If you view the source of the page in your browser you
				should see well formed XHTML content that includes the
				content defined in the layout as well as the content
				rendered by the view.
			</para>
			<note>
				<para>
					Should you wish to run the application using
					Microsoft Internet Information Services, you must
					associate the extension you selected (i.e.
					<literal>.castle</literal>
					) with the ASP.Net ISAPI. For more information on
					this please see the chapter entitled
					<link linkend="installation"
						endterm="installation.title" />
					.
				</para>
			</note>
		</section>
		<section>
			<title>Passing Values to a View</title>
			<para>
				As shown by the excessively simple view example used
				earlier, views are pretty useless unless you can pass
				custom values to them for rendering at runtime. The main
				mechanism for transferring values from the controller to
				the view is the
				<property>PropertyBag</property>
				.Values placed in the
				<property>PropertyBag</property>
				will be made available to the view template, however
				each view engine will provide access to these values
				differently. Since we're using the NVelocity view engine
				the values in the
				<property>PropertyBag</property>
				will be exposed as NVelocity variables which begin with
				a
				<literal>$</literal>
				symbol in the NVelocity view template.
			</para>
			<para>
				To demonstrate this principle let's create another
				action on our
				<classname>HomeController</classname>
				.
			</para>
			<programlisting language="cs"><![CDATA[
[Layout("default"), Rescue("generalerror")]
public class HomeController : SmartDispatcherController
{
	public void Index()
	{
	}
	
	public void DataToTheView()
	{
		PropertyBag["name"] = "John Doe";
		PropertyBag["today"] = DateTime.Now;
		
		RenderView("data");
	}
}
]]></programlisting>
			<para>
				The new
				<methodname>DataToTheView</methodname>
				action uses the
				<property>PropertyBag</property>
				to pass data to the view. It then invokes the built-in
				<methodname>RenderView</methodname>
				method on the controller to specify that the
				<filename>/views/home/data.vm</filename>
				view template should be rendered instead of the default
				<filename>/views/home/datatotheview.vm</filename>
				template.
			</para>
			<para>
				Now let's create the
				<literal>data.vm</literal>
				template in the
				<literal>\views\home</literal>
				folder.
			</para>
			<programlisting language="nv"><![CDATA[
<h3> Hello $name! </h3>

<h4> Today is $today.ToShortDateString() </h4>
]]></programlisting>
			<para>
				To see the result of the change run the application and
				visit
				<literal>home/datatotheview.castle</literal>
				in your browser.
			</para>
		</section>
		<section>
			<title>Creating a Rescue</title>
			<para>
				In an earlier step we specified that our controller uses
				a
				<emphasis>rescue</emphasis>
				. A rescue is a special purpose view template that will
				be rendered only in the event that an exception is
				thrown while executing an action on a controller.Lets
				create the rescue view to report errors nicely and see
				how it works.
			</para>
			<para>
				First, create a view template named
				<literal>generalerror.vm</literal>
				in the
				<literal>\views\rescues</literal>
				folder with the following content.
			</para>
			<programlisting language="nv"><![CDATA[
#macro(showexception $exc)
<b>$exc.GetType().Name</b>

Message:
$exc.Message

#if($exc.StackTrace)
StackTrace:
$exc.StackTrace
#end

#if($exc.InnerException)
<b>Inner exception:</b>
#set($inner = $exc.InnerException)
#showexception($inner)
#end
#end

<h2>Unexpected error happened</h3>

<p> This is the rescue page. See the exception details below </p>

<pre>
#set($exception = $context.LastException)
#showexception($exception)
</pre>
]]></programlisting>
			<para>
				Now lets create a new action that will throw an
				exception so we can see the rescue template in action.
			</para>
			<programlisting language="cs"><![CDATA[
[Layout("default"), Rescue("generalerror")]
public class HomeController : SmartDispatcherController
{
	public void Index()
	{
	}
	
	public void ErroneousAction()
	{
		throw new Exception("I'm a bad bad action.");
	}
	
	public void DataToTheView()
	{
		PropertyBag["name"] = "John Doe";
		PropertyBag["today"] = DateTime.Now;
		
		RenderView("data");
	}
}
]]></programlisting>
			<para>
				Run the application and go to
				<literal>home/erroneousaction.castle</literal>
				in your browser to trigger the exception and see the
				result.
			</para>
		</section>
	</section>
	<section>
		<title>Data Binding</title>
		<para>
			Although the controller we've been using so far in our
			sample application extends from
			<classname>SmartDispatcherController</classname>
			we haven't yet used any of its capabilities. The
			<classname>SmartDispatcherController</classname>
			base class, as the name implies, provides some "smart"
			functionality, including binding query string entries, form
			entries and even cookies to parameters of action methods
			when they are invoked.
		</para>
		<section>
			<title>Simple Parameters</title>
			<para>
				Simple types can be bound to parameters on with no
				special configuration other than to ensure your
				controller is derived from the
				<classname>SmartDispatchController</classname>
				class. For example, suppose you have the following form
				on a view:
			</para>
			<programlisting language="xml"><![CDATA[
<form action="/home/saveinformation.castle" method="post" >
	<input type="text" name="name" value="John doe" />
	<input type="text" name="age" value="30" />
	<input type="text" name="dob" value="07-16-1979" />
	<input type="submit" value="Send" />
</form>
]]></programlisting>
			<para>
				You can create the
				<methodname>SaveInformation</methodname>
				action in such a way that it will expect the values from
				the submitted HTML form as parameters to the method:
			</para>
			<programlisting language="cs"><![CDATA[
public class HomeController : SmartDispatcherController
{
	public void Index()
	{
	}
	
	public void SaveInformation(String name, int age, DateTime dob)
	{
		// work work work
		
		// Send the user back to the index 
		RedirectToAction("index");
	}
}
]]></programlisting>
			<para>
				Using this automatic databinding feature reduces the
				work you need to do to access the values submitted by
				the view. You could still access the values from the
				HTML form without data binding through use of the
				<property>Params</property>
				or
				<property>Form</property>
				name-value collections exposed by the controller,
				however data binding is cleaner and simpler. The code
				sample below provides the same functionality as the
				sample above - we will leave it to you to decide which
				is clearer to use.
			</para>
			<programlisting language="cs"><![CDATA[
public class HomeController : SmartDispatcherController
{
	public void Index()
	{
	}
	
	public void SaveInformation()
	{
		String name = Params["name"];
		int age = Convert.ToInt32(Params["age"]);
		DateTime dob = Convert.ToDateTime(Params["dob"]);
	
		// work work work
		
		// Send the user back to the index 
		RedirectToAction("index");
	}
}
]]></programlisting>
			<para>
				The
				<classname>SmartDispatchController</classname>
				is capable of handling a wide range of types. For
				further details on the types supported refer to the
				documentation on
				<link linkend="controllers.databinding">
					Data Binding
				</link>
				in the
				<link linkend="controllers">Controllers</link>
				chapter.
			</para>
		</section>
		<section>
			<title>Complex Objects</title>
			<para>
				You can also use the
				<classname>SmartDispatcherController</classname>
				to populate custom and arbitrarily complex objects. To
				illustrate how this can be achieved we will create a new controller that presents a
				contact form designed to allow a user to contact a department
				in a fictitious company.
			</para>
			<para>
				<orderedlist>
					<listitem>
						<para>
							Create a new controller named
							<classname>ContactController</classname>
							and include two actions:
							<methodname>ContactForm</methodname>
							and
							<methodname>SendContactMessage</methodname>
							.
						</para>
						<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Controllers
{
	using System;
	using Castle.MonoRail.Framework;

	[Layout("default"), Rescue("generalerror")]
	public class ContactController : SmartDispatcherController
	{
		public void ContactForm()
		{
		}
		
		public void SendContactMessage()
		{
		}
	}
}
]]></programlisting>
					</listitem>
					<listitem>
						<para>
							Create a class
							<classname>Contact</classname>
							that represents the contact information.
						</para>
						<programlisting language="cs"><![CDATA[
public class Contact
{
	private string from;
	private string area;
	private string subject;
	private string message;

	public string From
	{
		get { return from; }
		set { from = value; }
	}

	public string Area
	{
		get { return area; }
		set { area = value; }
	}

	public string Subject
	{
		get { return subject; }
		set { subject = value; }
	}

	public string Message
	{
		get { return message; }
		set { message = value; }
	}
}
]]></programlisting>

					</listitem>
					<listitem>
						<para>
							Now create the view for the
							<methodname>ContactForm</methodname>
							action. The view name should be
							<literal>contactform.vm</literal>
							and should be put on
							<filename>Views\Contact</filename>
							folder.
						</para>
						<programlisting language="xml"><![CDATA[
<h2>Contact us!</h2>

<p>
We are interested in hearing from you.
</p>

<form action="SendContactMessage.rails" method="post">

<p>
From: $FormHelper.TextField("contact.from")
</p>

<p>
Area: $FormHelper.TextField("contact.area") (Sales, Support)
</p>

<p>
Subject: $FormHelper.TextField("contact.subject", "%{size='30'}")
</p>

<p>
Message: <br/> 
$FormHelper.TextArea("contact.message", "%{cols='35', rows='6'}")
</p>

<hr />

<p>
<input type="submit" value="Send the message" />
</p>

</form>
]]></programlisting>
						<para>
							Note that we used the
							<classname>FormHelper</classname>
							which handles generation of form elements.
							You can (and should) learn more about
							helpers and especially the
							<classname>FormHelper</classname>
							on the documentation.
						</para>

						<para>
							You should also note that the each generated
							field on the html will be prefixed with
							<literal>contact</literal>
							, for example
							<literal>contact.name</literal>
							. This is important as to use MonoRail's
							data bind you must prefix the form elements
							to avoid name clashes.
						</para>

					</listitem>
					<listitem>
						<para>
							Finally change the action to bind the form
							data to the
							<classname>Contact</classname>
							class:
						</para>
						<programlisting language="cs"><![CDATA[
public void SendContactMessage([DataBind("contact")] Contact contact)
{
	// Pretend to save the contact ...
	
	// ..work work work..
	
	// Now lets add the contact to the property bag
	// so we can render a nice message back to the user
	
	PropertyBag["contact"] = contact;
	
	RenderView("confirmation");
}
]]></programlisting>
						<para>
							We used the
							<classname>DataBindAttribute</classname>
							on the action parameter. Its first parameter
							is the prefix used on the form. In our case
							it is
							<literal>contact</literal>
							. When this action is invoked, MonoRail will
							try to match the form data with the
							properties on the
							<classname>Contact</classname>
							class and create an new instance populating
							the properties.
						</para>
					</listitem>
					<listitem>
						<para>
							It would be nice to create the
							<literal>confirmation</literal>
							view too:
						</para>
						<programlisting language="xml"><![CDATA[
<p>

Thanks $!contact.from, we have received your message and will
get back to your shortly.

</p>
]]></programlisting>
					</listitem>
				</orderedlist>
			</para>
			<para>
				Now test your work by running the application and
				accessing
				<literal>/contact/contactform.rails</literal>
				. Fill the form elements and submit it.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_contact_1.png" />
					</imageobject>
				</mediaobject>
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_contact_2.png" />
					</imageobject>
				</mediaobject>
			</para>
		</section>
	</section>
	<section>
		<title>Integrating with ActiveRecord</title>
		<para>
			In order to explorer some more realistics scenarios you will
			face in daily developments, why not use ActiveRecord as our
			database access approach? All you have to do is reference
			the assemblies, set up a database and configure and
			initialize ActiveRecord.
		</para>
		<section>
			<title>Adding Assemblies</title>
			<para>
				<orderedlist>
					<listitem>
						<para>
							First of all, add references to the
							following assemblies:

							<itemizedlist>
								<listitem>
									<para>
										<literal>
											Castle.ActiveRecord.dll
										</literal>
									</para>
								</listitem>
								<listitem>
									<para>
										<literal>
											Castle.DynamicProxy.dll
										</literal>
									</para>
								</listitem>
								<listitem>
									<para>
										<literal>
											Iesi.Collections.dll
										</literal>
									</para>
								</listitem>
								<listitem>
									<para>
										<literal>log4net.dll</literal>
									</para>
								</listitem>
								<listitem>
									<para>
										<literal>
											NHibernate.dll
										</literal>
									</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>
				</orderedlist>
			</para>
		</section>
		<section>
			<title>Configuration</title>
			<para>
				Now include a section on the
				<filename>web.config</filename>
				so you can keep ActiveRecord's configuration there:
			</para>
			<programlisting language="xml"><![CDATA[
<configuration>
	<configSections>
		<section 
			name="monorail" 
			type="Castle.MonoRail.Framework.Configuration.MonoRailSectionHandler, Castle.MonoRail.Framework" />
		<section 
			name="activerecord"
			type="Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler, Castle.ActiveRecord" />
	</configSections>
	
	<activerecord isWeb="true">
	    
		<config>
			<add 
				key="hibernate.connection.driver_class" 
				value="NHibernate.Driver.SqlClientDriver" />
			<add 
				key="hibernate.dialect"                 
				value="NHibernate.Dialect.MsSql2000Dialect" />
			<add 
				key="hibernate.connection.provider"     
				value="NHibernate.Connection.DriverConnectionProvider" />
			<add 
				key="hibernate.connection.connection_string" 
				value="Data Source=.;Initial Catalog=test;Integrated Security=SSPI" />
		</config>
	    
	</activerecord>
	
	...
]]></programlisting>
			<note>
				<para>
					The configuration above uses SQL Server 2000. If you
					are using a different database you need to change
					the dialect. Please refer to the
					<ulink
						url="../documentation/trunk/manual/configurationref.html">
						Xml Configuration Reference
					</ulink>
					document for more information.
				</para>
			</note>

			<para>
				This configuration access a database catalog named
				<literal>test</literal>
				. Make sure it exists or change the configuration to
				access an existing database catalog.
			</para>
		</section>
		<section>
			<title>Building the Model</title>
			<para>
				Create two models to represent products and suppliers.
				You can create the classes on the
				<filename>Models</filename>
				folder.
			</para>
			<para>
				The
				<filename>Supplier.cs</filename>
				:
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Models
{
	using System;
	using Castle.ActiveRecord;
	using NHibernate.Expression;

	[ActiveRecord]
	public class Supplier : ActiveRecordBase
	{
		private int id;
		private String name;

		[PrimaryKey]
		public int Id
		{
			get { return id; }
			set { id = value; }
		}

		[Property]
		public string Name
		{
			get { return name; }
			set { name = value; }
		}
		
		/// <summary>
		/// Returns the Suppliers ordered by Name
		/// </summary>
		/// <returns>Suppliers array</returns>
		public static Supplier[] FindAll()
		{
			return (Supplier[]) FindAll(typeof(Supplier), new Order[] { Order.Asc("Name") });
		}
	}
}
]]></programlisting>
			<para>
				The
				<filename>Product.cs</filename>
				:
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Models
{
	using System;
	using Castle.ActiveRecord;

	[ActiveRecord]
	public class Product : ActiveRecordBase
	{
		private int id;
		private String name;
		private decimal price;
		private Supplier supplier;

		[PrimaryKey]
		public int Id
		{
			get { return id; }
			set { id = value; }
		}

		[Property]
		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		[Property]
		public decimal Price
		{
			get { return price; }
			set { price = value; }
		}

		[BelongsTo("SupplierId")]
		public Supplier Supplier
		{
			get { return supplier; }
			set { supplier = value; }
		}
		
		public static Product[] FindAll()
		{
			return (Product[]) FindAll(typeof(Product));
		}
		
		public static Product FindById(int id)
		{
			return (Product) FindByPrimaryKey(typeof(Product), id);
		}
	}
}
]]></programlisting>
		</section>
		<section>
			<title>Initializing the Handler</title>
			<para>
				The last step is to initialize ActiveRecord passing the
				configuration. The best place to do that in a web
				application is on the global.asax related class. So
				create a
				<filename>global.asax</filename>
				if none exists and on the related class, use the
				<methodname>Application_OnStart</methodname>
				event to initialize ActiveRecord:
			</para>
			<para>
				The
				<filename>global.asax</filename>
				file:
			</para>
			<programlisting language="xml"><![CDATA[
<%@ Application Inherits="GettingStartedSample.GlobalApplication" %>
]]></programlisting>
			<para>
				The
				<filename>GlobalApplication.cs</filename>
				file:
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample
{
	using System;
	using System.Web;
	using Castle.ActiveRecord;
	using Castle.ActiveRecord.Framework.Config;
	using GettingStartedSample.Models;
	

	public class GlobalApplication : HttpApplication
	{
		public GlobalApplication()
		{
		}

		public void Application_OnStart()
		{
			ActiveRecordStarter.Initialize(ActiveRecordSectionHandler.Instance, 
			                               new Type[] { typeof(Supplier), typeof(Product) });
			
			// If you want to let ActiveRecord create the schema for you:
			ActiveRecordStarter.CreateSchema();
		}

		public void Application_OnEnd() 
		{
		}
	}
}
]]></programlisting>
			<para>
				The next time you run the application it will create the
				tables for you, so you can comment the line that invokes
				<methodname>CreateSchema</methodname>
				after that.
			</para>
		</section>
		<section>
			<title>ActiveRecord Sacffolding</title>
			<para>
				First lets handle inclusion the easy way. By using
				ActiveRecord Scaffolding support we can have a crud page
				with no effort. However Scaffolding is meant to be used
				to prototype applications only, as you can get something
				working really fast. During the application lifecycle
				you should replace the scaffolded controller with a more
				suitable crud implementation (which we will see in the
				next page).
			</para>
			<para>
				Enabling ActiveRecord Scaffolding is real simple.
			</para>
			<section>
				<title>Adding Assemblies</title>
				<para>
					First of all, add references to the following
					assemblies:
					<itemizedlist>
						<listitem>
							<para>
								<literal>
									Castle.MonoRail.ActiveRecordScaffold.dll
								</literal>
							</para>
						</listitem>
						<listitem>
							<para>
								<literal>
									Castle.MonoRail.ActiveRecordSupport.dll
								</literal>
							</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
			<section>
				<title>Creating the Controller</title>
				<para>
					Now create a controller to manage the
					<classname>Supplier</classname>
					class:
				</para>
				<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Controllers
{
	using System;
	using Castle.MonoRail.Framework;
	using GettingStartedSample.Models;

	[Scaffolding(typeof(Supplier))]
	public class SupplierController : Controller
	{
	}
}
]]></programlisting>
				<para>
					Note the usage of the
					<classname>ScaffoldingAttribute</classname>
				</para>
			</section>
			<section>
				<title>Viewing the Result</title>
				<para>
					That is it. Now run the application and direct your
					browser to
					<literal>/supplier/list.rails</literal>
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="images/gs_scaffold_1.png" />
						</imageobject>
					</mediaobject>
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="images/gs_scaffold_2.png" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
		</section>
		<section>
			<title>Creating a CRUD Page Using DataBind</title>
			<para>
				CRUD stands for Create, Retrieve, Update and Delete.
				Most applications have some kind of CRUD funcionality,
				and we can assume that every programmer had to deal with
				CRUD at some point.
			</para>
			<para>
				As you remember, we have created a
				<classname>Supplier</classname>
				and
				<classname>Product</classname>
				classes. We used scaffolding to create the CRUD for the
				<classname>Supplier</classname>
				class. Now let's code the CRUD for the
				<classname>Product</classname>
				class manually. You'll see that it is also something
				really simple.
			</para>
			<para>
				The first thing you must do is create the
				<classname>ProductController</classname>
				:
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Controllers
{
	using System;
	using Castle.MonoRail.Framework;
	using GettingStartedSample.Models;

	[Layout("default"), Rescue("generalerror")]
	public class ProductController : SmartDispatcherController
	{
	}
}
]]></programlisting>
			<para>Now we are ready.</para>
			<section>
				<title>Presenting the List</title>
				<para>
					Create a
					<methodname>List</methodname>
					action on the controller:
				</para>
				<programlisting language="cs"><![CDATA[
public void List()
{
	PropertyBag["products"] = Product.FindAll();
}
]]></programlisting>
				<para>
					This code makes all products available to the view.
					Now create the
					<literal>list.vm</literal>
					:
				</para>
				<programlisting language="xml"><![CDATA[
<h3>Product list</h3>

<p>
<a href="new.rails">Create new Product</a>
</p>

<table width="100%" border="1" cellpadding="2" cellspacing="0">
<tr>
	<th>Id</th>
	<th>Name</th>
	<th>Supplier</th>
	<th>&nbsp;</th>
</tr>
#foreach($product in $products)
<tr>
	<td align="center">$product.Id</td>
	<td align="center">$product.Name</td>
	<td align="center">$product.Supplier.Name</td>
	<td align="center">
		<a href="edit.rails?id=${product.Id}">Edit</a> | 
		<a href="delete.rails?id=${product.Id}">Delete</a>
	</td>
</tr>
#end
</table>
]]></programlisting>
				<para>
					Test your working accessing
					<literal>/product/list.rails</literal>
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/gs_crud_2.png" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section>
				<title>Creating</title>
				<para>
					To insert a new product we will use two actions:
					<itemizedlist>
						<listitem>
							<para>
								<methodname>New</methodname>
								: which will present the form
							</para>
						</listitem>
						<listitem>
							<para>
								<methodname>Create</methodname>
								: which uses the data supplied on the
								form to create the Product on the
								database
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<programlisting language="cs"><![CDATA[
public void New()
{
	PropertyBag["suppliers"] = Supplier.FindAll();
}

public void Create([DataBind("product")] Product prod)
{
	try
	{
		prod.Create();
	
		RedirectToAction("list");
	}
	catch(Exception ex)
	{
		Flash["error"] = ex.Message;
		Flash["product"] = prod;
		
		RedirectToAction("new");
	}
}
]]></programlisting>
				<para>
					The
					<methodname>New</methodname>
					action makes all suppliers available to the view.
					This is required to populate a select element with
					all suppliers available.
				</para>
				<para>
					The
					<literal>new.vm</literal>
					view follows:
				</para>
				<programlisting language="xml"><![CDATA[
<h3>New Product</h3>

#if($Flash.error)
<p style="color: red; font-weight: bold;">
	$Flash.error
</p>
#end

<form action="create.rails" method="post">

	<p>
	Name: $FormHelper.TextField("product.name")
	</p>

	<p>
	Price: $FormHelper.TextFieldFormat("product.price", "000.00")
	</p>

	<p>
	Supplier: $FormHelper.Select("product.supplier.id", $suppliers, "%{value='Id', text='Name'}")
	</p>

	<hr/>

	<p>
	<input type="submit" value="Create" />
	</p>

</form>
]]></programlisting>
				<para>
					Test your working accessing
					<literal>/product/new.rails</literal>
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/gs_crud_1.png" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section>
				<title>Updating</title>
				<para>
					Updating is not very different from creating. First
					create two actions:
					<methodname>Edit</methodname>
					and
					<methodname>Update</methodname>
					.
				</para>
				<programlisting language="cs"><![CDATA[
public void Edit(int id)
{
	PropertyBag["product"] = Product.FindById(id);
	PropertyBag["suppliers"] = Supplier.FindAll();
}

public void Update([DataBind("product")] Product prod)
{
	try
	{
		prod.Update();
	
		RedirectToAction("list");
	}
	catch(Exception ex)
	{
		Flash["error"] = ex.Message;
		Flash["product"] = prod;
		
		RedirectToAction("edit", "id=" + prod.Id);
	}
}
]]></programlisting>
				<para>
					We can also use a different
					<methodname>Edit</methodname>
					overload that will be used when the
					<methodname>Update</methodname>
					catch block redirects it back to the
					<methodname>Edit</methodname>
					:
				</para>
				<programlisting language="cs"><![CDATA[
public void Edit(int id, [FlashBinder] Product product)
{
	PropertyBag["suppliers"] = Supplier.FindAll();
}
]]></programlisting>
				<para>
					The
					<literal>edit.vm</literal>
					view is pratically the same as the
					<literal>new.vm</literal>
					. The
					<classname>FormHelper</classname>
					is clever enough to populate the fields and select
					the correct item on the form's
					<literal>select</literal>
					element.
				</para>
				<programlisting language="xml"><![CDATA[
<h3>Edit Product</h3>

#if($Flash.error)
<p style="color: red; font-weight: bold;">
	$Flash.error
</p>
#end

<form action="update.rails" method="post">

$FormHelper.HiddenField("product.id")

	<p>
	Name: $FormHelper.TextField("product.name")
	</p>

	<p>
	Price: $FormHelper.TextFieldFormat("product.price", "000.00")
	</p>

	<p>
	Supplier: $FormHelper.Select("product.supplier.id", $suppliers, "%{value='Id', text='Name'}")
	</p>

	<hr/>

	<p>
	<input type="submit" value="Update" />
	</p>

</form>
]]></programlisting>
			</section>
			<section>
				<title>Deleting</title>
				<para>
					Deleting is the easiest one. Add the
					<methodname>Delete</methodname>
					action:
				</para>
				<programlisting language="cs"><![CDATA[
public void Delete(int id)
{
	Product product = Product.FindById(id);
	
	product.Delete();
	
	RedirectToAction("list");
}
]]></programlisting>
			</section>
		</section>
	</section>
	<section>
		<title>Final Comments</title>
		<para>
			Getting Started gave you a very fast introduction to what
			MonoRail is capable of and how to use it. But there are much
			more to learn. Explore the samples, stretch and bend it as
			you wish, and consult the documentation which contains much
			more in-depth information.
		</para>
	</section>
</chapter>