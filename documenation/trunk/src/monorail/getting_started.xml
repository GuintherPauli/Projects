<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../../toolchain/docbook-xml/docbookx.dtd">
<chapter id="getting_started">
	<title id="getting_started.title">Getting Started</title>
	<section>
		<title>Introduction</title>
		<para>
			Castle MonoRail greatly simplifies web development. The
			Getting Started chapter is going to show you how common
			tasks are handled and how MonoRail performs most of the
			repetitive work in web development on your behalf.
		</para>
		<para>
			Among other things you will learn
			<itemizedlist>
				<listitem>
					<para>
						About
						<emphasis>controllers</emphasis>
						and
						<emphasis>views</emphasis>
						and how they relate to each other
					</para>
				</listitem>
				<listitem>
					<para>
						How to use
						<emphasis>layouts</emphasis>
						and
						<emphasis>rescues</emphasis>
					</para>
				</listitem>
				<listitem>
					<para>
						How to use the
						<classname>SmartDispatcherController</classname>
						and the data binder
					</para>
				</listitem>
				<listitem>
					<para>How to easily create a CRUD page</para>
				</listitem>
				<listitem>
					<para>
						How Castle
						<ulink
							url="http://www.castleproject.org/activerecord/index.html">
							ActiveRecord
						</ulink>
						integrates nicely with MonoRail
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			Although it should go without saying, you are not obliged to
			use ActiveRecord as your primary data access framework with
			MonoRail - you can use whatever approach to performing data
			access you like. That being said if you do use ActiveRecord,
			there are some provided integrations that might save you
			some time. Regardless, the framework provided allows you to
			develop similar integration for your preferred data access
			approach should you choose to do so.
		</para>
		<tip>
			<para>
				You can also download the complete example demonstrating
				the concepts from
				<ulink
					url="http://www.castleproject.org/download/monorail/v1rc2/MonoRail.GettingStartedSampleVS2005.zip">
					here.
				</ulink>
			</para>
		</tip>
	</section>
	<section>
		<title>Requirements</title>
		<para>
			For the purposes of this chapter we will assume that you
			have Castle Project assemblies present on your local
			machine. If you don't, we encourage you to download the
			<ulink
				url="http://www.castleproject.org/castle/download.html">
				MSI installer distribution
			</ulink>
			as it automatically installs all the required assemblies in
			the Global Assembly Cache, making them available to Visual
			Studio.
		</para>
		<para>
			Also, during the course of this chapter will be using a
			database. For simplicity's sake all discussion surrounding
			database configuration will refer ot MSSQL Server 2000
			however if you prefer to use another database you can select
			any other database supported by NHibernate and will find
			very little deviation from the text in this chapter.
		</para>
	</section>
	<section>
		<title>Creating the Project Skeleton</title>
		<para>
			As mentioned in the
			<link
				linkend="introduction.convention_over_configuration">
				Introduction
			</link>
			MonoRail tends to favour convention over configuration and
			when creating a project structure we encourage you to use a
			project structure similar to the following to remain in line
			with these conventions.
		</para>

		<mediaobject>
			<imageobject>
				<imagedata fileref="images/gs_folders.png" />
			</imageobject>
		</mediaobject>

		<!-- TODO: Further explanation as to *why* would be nice here. -->

		<para>
			You are by no means
			<emphasis>required</emphasis>
			to follow these conventions, however they will most likely
			made development easier for you in the long run. The
			following sections show you how to create this structure
			manually or by using the MonoRail project wizard and will
			further explain the reasoning behind its use.
		</para>
		<section>
			<title>Using the MonoRail Project Wizard</title>
			<para>
				If you have installed Castle Project using the MSI
				installer you are likely to have the Visual Studio
				Integration installed as well. Should that be the case
				the easiest way to create a new MonoRail project is the
				use the Castle MonoRail Project Wizard.
			</para>
			<warning>
				<para>
					The Castle MonoRail Project template described below
					requires that your Visual Studio installation has
					Web Project support installed. Visual Studio 2005
					does not come with Web Project support out of the
					box, however there are two options for adding Web
					Project support to Visual Studio; you can install
					the
					<ulink
						url="http://msdn2.microsoft.com/en-us/asp.net/aa336618.aspx">
						Web Project support
					</ulink>
					add in, or alternately you can ensure your Visual
					Studio installation is upgraded to
					<ulink
						url="http://msdn2.microsoft.com/en-us/vstudio/bb265237.aspx">
						Visual Studio 2005 Service Pack 1
					</ulink>
					or later.
				</para>
			</warning>
			<para>
				To create a MonoRail project using the wizard just
				perform the following simple steps:
			</para>
			<orderedlist>
				<listitem>
					<para>
						Open Visual Studio and go to
						<menuchoice>
							<guimenu>New</guimenu>
							<guimenuitem>Project</guimenuitem>
						</menuchoice>
						. Under Visual Studio 2005 you will see the
						following dialog:
					</para>
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="images/gs_wizard2005.png" />
						</imageobject>
					</mediaobject>
				</listitem>
				<listitem>
					<para>
						Select the
						<emphasis>Castle MonoRail Project</emphasis>
						template, enter
						<userinput>GettingStartedSample</userinput>
						as the name for your new project then click the
						<guibutton>OK</guibutton>
						button.
					</para>
				</listitem>
				<listitem>
					<para>
						When the wizard starts select the
						<option>NVelocity View Engine</option>
						from the list of View Engines and click the
						<guibutton>Next</guibutton>
						button.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="images/gs_wizard2005_1.png" />
							</imageobject>
						</mediaobject>
					</para>
					<note>
						<para>
							Do not enable Windsor Integration or Routing
							at this stage.
						</para>
					</note>
				</listitem>
				<listitem>
					<para>
						The next step in the wizard will offer the
						option to create a Test project where unit tests
						for your new MonoRail application can be
						created. Ensure the checkbox to create the test
						project is checked then click the
						<guibutton>Finish</guibutton>
						button.
					</para>
				</listitem>
			</orderedlist>
			<para>
				Once all of the above steps have been completed the
				wizard will create the solution, the web project and the
				test project and will set up all the basic configuration
				required for MonoRail to run.
			</para>
		</section>
		<section>
			<title>Creating the Project Manually</title>
			<para>
				If you haven't installed the Visual Studio integration
				or would prefer not to use the project wizard and
				instead would rather set up the project structure by
				hand you can follow the steps outlined below.
			</para>
			<section>
				<title>Create the Project</title>
				<para>
					Create an
					<emphasis>ASP.Net Web Application</emphasis>
					project in Visual Studio 2005. Name the new project
					<userinput>GettingStartedSample</userinput>
					then click the
					<guibutton>OK</guibutton>
					button.
				</para>
				<tip>
					<para>
						If the
						<emphasis>ASP.Net Web Application</emphasis>
						template is not present in your Visual Studio
						installation you can create a
						<emphasis>Class Library</emphasis>
						project instead.
					</para>
				</tip>
			</section>
			<section>
				<title>Reference the MonoRail Assemblies</title>
				<para>
					To make the new project into a MonoRail application
					you will need to add references to the MonoRail
					assemblies. For the purposes of our sample
					application the assemblies listed below will be
					required.
				</para>
				<para>
					<informaltable>
						<tgroup cols='2' align='left' colsep='1'
							rowsep='1'>
							<colspec colname='c1' />
							<colspec colname='c2' />
							<thead>
								<row>
									<entry>Assembly</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										Castle.MonoRail.Framework.dll
									</entry>
									<entry>
										Contains the classes that make
										up the core of the MonoRail
										framework.
									</entry>
								</row>
								<row>
									<entry>
										Castle.MonoRail.Framework.Views.NVelocity.dll
									</entry>
									<entry>
										Defines an NVelocity view engine
										plugin that will be used for
										handling views. This will in
										turn use the NVelocity rendering
										engine.
									</entry>
								</row>
								<row>
									<entry>
										Castle.Components.Validator.dll
									</entry>
									<entry>
										Provides a lightweight
										validation infrastructure
										created by Castle.
									</entry>
								</row>
								<row>
									<entry>
										Castle.Components.Binder.dll
									</entry>
									<entry>
										Contains the logic for the
										databinding that is used in
										MonoRail.
									</entry>
								</row>
								<row>
									<entry>
										Castle.Components.Common.EmailSender.dll
									</entry>
									<entry>
										Defines the interface for
										components that send email.
									</entry>
								</row>
								<row>
									<entry>
										Castle.Components.Common.EmailSender.SmtpEmailSender.dll
									</entry>
									<entry>
										Provides an SMTP implementation
										of the EmailSender that will be
										responsible for sending email.
									</entry>
								</row>
								<row>
									<entry>Castle.Core.dll</entry>
									<entry>
										Core Castle class library
										containing functionality used by
										many projects, including
										MonoRail.
									</entry>
								</row>
								<row>
									<entry>NVelocity.dll</entry>
									<entry>
										The NVelocity template engine
										used for rendering NVelocity
										templates.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</para>
			</section>
			<section>
				<title>Create the Project Folders</title>
				<para>
					The next step is to create the following folders on
					the project. Again, this is just a convention we
					encourage you to follow - you may come up with a
					more suitable convention for your projects after you
					get used to the framework so this is no way
					mandatory.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/gs_solution.png" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section>
				<title>Configuration</title>
				<para>
					To configure the application additional information
					needs to be added to the
					<filename>web.config</filename>
					file; you must register the MonoRail configuration
					handler, the MonoRail configuration section, an HTTP
					handler and an HTTP module. Each of these will be
					discussed further below.
				</para>
				<para>
					First, add the MonoRail configuration handler:
				</para>

				<programlisting language="xml"><![CDATA[
<configuration>
	<configSections>
		<section 
			name="monorail" 
			type="Castle.MonoRail.Framework.Configuration.MonoRailSectionHandler, Castle.MonoRail.Framework" />
	</configSections>
	
	...
]]></programlisting>
				<para>
					Next add the
					<code><![CDATA[<monorail>]]></code>
					configuration section.
				</para>
				<programlisting language="xml"><![CDATA[
	...
	
	<monorail>
		<controllers>
			<assembly>GettingStartedSample</assembly>
		</controllers>
		
		<viewEngines viewPathRoot="Views">
			<add type="Castle.MonoRail.Framework.Views.NVelocity.NVelocityViewEngine, Castle.MonoRail.Framework.Views.NVelocity" />
		</viewEngines>
	</monorail>
	
	...
]]></programlisting>
				<para>
					This is the section that will contain all the
					configuration that controls setting up and
					customizing the behavior of MonoRail itself. The
					elements included for our sample above are the
					<literal><![CDATA[<controllers>]]></literal>
					node that defines the list of assemblies that
					contain the controllers for the application and the
					<literal><![CDATA[<viewEngines>]]></literal>
					node the specifies the view engine that will handle
					rendering the view templates in the application.
					There are more configuration options available in
					the
					<link linkend="configuration"
						endterm="configuration.title" />
					chapter, however the elements above are sufficient
					for this sample.
				</para>
				<para>
					It should be noted at this point that we have chosen
					the NVelocity view engine for rendering the views in
					our application.
					<application>NVelocity</application>
					is a very simple template engine that supports
					conditional statements, assignments, array creation,
					and iteration over collections that provides all the
					functionality you will generally need during the
					rendering of a view. You can learn more about
					<application>NVelocity</application>
					(and how we have improved it) on
					<ulink
						url="http://www.castleproject.org/others/nvelocity/index.html">
						its page
					</ulink>
					.
				</para>
				<para>
					Next we will add a couple of HTTP Handlers under the
					<literal><![CDATA[<httpHandlers>]]></literal>
					node in the
					<literal><![CDATA[<system.web>]]></literal>
					section of the
					<filename>web.config</filename>
					.
				</para>
				<programlisting language="xml"><![CDATA[
...
	
	<system.web>
		<httpHandlers>
		
			<add 
				verb="*" 
				path="*.castle" 
				type="Castle.MonoRail.Framework.MonoRailHttpHandlerFactory, Castle.MonoRail.Framework" />
			
			<add 
				verb="*" 
				path="*.vm" 
				type="System.Web.HttpForbiddenHandler"/>
				
		</httpHandlers>
		
		...
-
]]></programlisting>
				<para>
					The first HTTP Handler is responsible for routing
					incoming requests to MonoRail based on their
					extension. The example above indicates that incoming
					requests ending in
					<literal>.castle</literal>
					should be handled by MonoRail. If you prefer another
					extension such as
					<literal>.rails</literal>
					you can simply change the value of the
					<literal>path</literal>
					attribute to your preferred value.
				</para>
				<para>
					The second handler is present as a security
					consideration. It is important to to be aware that
					if a file in a web folder is accessed from the
					outside world its contents will normally be sent
					directly to the calling browser. To prevent the
					source for your view files from being visible to the
					outside world an
					<classname>HttpForbiddenHandler</classname>
					needs to be configured for the file extension of any
					files you don't want want to be directly accessible.
					In this case, because we chose to use the NVelocity
					view engine and our view templates use the
					<literal>.vm</literal>
					extension this is the extension we have associated
					with the
					<classname>HttpForbiddenHandler</classname>
					.
				</para>
				<para>
					Finally you need to register the MonoRail HTTP
					module that handles incoming requests into the
					<literal><![CDATA[<httpModules>]]></literal>
					node, which is also found in the
					<literal><![CDATA[<system.web>]]></literal>
					section.
				</para>
				<programlisting language="xml"><![CDATA[
		...
		
		<httpModules>
			<add 
				name="monorail" 
				type="Castle.MonoRail.Framework.EngineContextModule, Castle.MonoRail.Framework" />
		</httpModules>
	</system.web>
	
</configuration>
]]></programlisting>
				<para>
					That's it - the configuration is now complete. Next
					we will start exploring controllers, actions and
					views.
				</para>
			</section>
		</section>
	</section>
	<section>
		<title>Controllers, Actions and Views</title>
		<para>
			For all MonoRail MVC applications the entry point for each
			request is the controller - this is the single largest
			deviation from the approach taken in Web Forms development
			where the entry point is the page itself. With MonoRail the
			controller is executed in response to a request where an
			action decides whether or not it should render a view and,
			if so, which one to render. As a result the controller has
			control over the application flow rather than the
			pages/views. This returns views to their original role: to
			present information - nothing more and nothing less.
		</para>
		<para>
			It is important at this point to understand the relationship
			between the structure of the MonoRail URL and how it relates
			to the controller and the method to execute on the
			controller. A common URL to a MonoRail web page might look
			like the following:
		</para>
		<para>
			<screen><![CDATA[
http://www.some-server.net/home/index.castle
|                         |    |     |      | 
+-------------------------+----+-----+------+
          ^                 ^     ^     ^
          |                 |     |     |
        Server              |     |     |
                            |     |     |
                      Controller  |     |
                                  |     |
                               Action   |
                                        |
                                    Extension
]]></screen>
		</para>
		<para>
			In the diagram above the extension
			<literal>.castle</literal>
			indicates that MonoRail should handle the request,
			<literal>home</literal>
			specifies the controller to use and
			<literal>index</literal>
			indicates that the
			<methodname>Index</methodname>
			action method on the controller should be executed. Since
			MonoRail prefers convention over configuration the default
			behaviour is for MonoRail to use the controller name in the
			URL to locate the controller class by appending the word
			<emphasis>Controller</emphasis>
			to the end, so in the event that the controller name
			<literal>home</literal>
			is found in the URL the controller class used in response to
			this request will be the
			<classname>HomeController</classname>
			class.
		</para>
		<section>
			<title>Your First Controller</title>
			<para>
				It is now time to create your first controller. If you
				have used the wizard to create the project, a
				<classname>HomeController</classname>
				class will already have been created for you. If it is
				not already present you should create a new class named
				<classname>HomeController</classname>
				in the
				<filename>Controllers</filename>
				folder of your project.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_controller_1.png" />
					</imageobject>
				</mediaobject>
			</para>
			<para>
				Inside the
				<classname>HomeController</classname>
				class the following code should be present. If you have
				just created the class file yourself you should add the
				code now.
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Controllers
{
	using System;

	using Castle.MonoRail.Framework;

	[Layout("default"), Rescue("generalerror")]
	public class HomeController : SmartDispatcherController
	{
		public void Index()
		{
		}
	}
}
]]></programlisting>
			<para>
				This is a pretty basic sample for the moment. Don't
				worry if you don't understand it at this point; we'll
				explain the code and surrounding concepts in more detail
				in the next section.
			</para>
		</section>
		<section>
			<title>The Index Action and View</title>
			<para>
				An
				<emphasis>action</emphasis>
				is a public non-static method exposed by a controller
				class. The controller shown in the previous section
				exposes just one action,
				<literal>Index</literal>
				which is empty, however due to MonoRail's convention
				over configuration approach the controller will render a
				specific view template by default.
			</para>
			<para>
				The view template chosen by MonoRail is affected by the
				view engine chosen during the configuration phase of the
				project. Since we chose to use the NVelocity view engine
				all of our view templates will end with the
				<literal>.vm</literal>
				extension.
			</para>
			<para>
				By default, the specific view template file chosen for
				rendering is based on the name of the action being
				executed and the folder in which the view template is
				located is based on the name of the controller handling
				the request. As a result the default view template
				chosen by the
				<methodname>Index</methodname>
				action on the
				<classname>HomeController</classname>
				will be
				<literal>index.vm</literal>
				located under the
				<filename>/views/home</filename>
				folder in the project.
			</para>
			<tip>
				<para>
					This behavior can be overridden in several ways that
					are covered later in this guide.
				</para>
				<!-- TODO: Is it? -->
			</tip>
			<para>
				If the view template
				<filename>index.vm</filename>
				does not yet exist in the
				<filename>/views/home</filename>
				folder of your project you should create it now.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_view_1.png" />
					</imageobject>
				</mediaobject>
			</para>
			<para>
				To illustrate a point we will make the content of the
				<literal>home.vm</literal>
				file nice and simple to start with. If the
				<literal>home.vm</literal>
				file does not contain the content below just copy and
				paste it in there.
			</para>
			<programlisting language="xml"><![CDATA[
<p>

Hello world from my first action.

</p>
]]></programlisting>
			<tip>
				<para>
					You can make Visual Studio use the HTML editor for
					<literal>.vm</literal>
					files. Use the
					<guimenuitem>Open With...</guimenuitem>
					option from the context menu.
				</para>
			</tip>
			<para>
				This is a fairly simple view; note that in the template
				we did not include the html or body tags. This is
				because we will leave those to the
				<emphasis>layout</emphasis>
				to render, which we will cover next.
			</para>
		</section>
		<section>
			<title>Setting the Layout and Rescue</title>
			<para>
				When we created the
				<classname>HomeController</classname>
				you may have noticed the
				<classname>Layout</classname>
				and
				<classname>Rescue</classname>
				attributes were specified on the class.
			</para>
			<programlisting language="cs"><![CDATA[
[Layout("default"), Rescue("generalerror")]
public class HomeController : SmartDispatcherController
]]></programlisting>
			<para>
				These attributes define the following:
				<itemizedlist>
					<listitem>
						<para>
							The
							<classname>Layout</classname>
							attribute indicates that every view rendered
							by this controller to should be wrapped in
							the content from the
							<filename>default.vm</filename>
							template in the
							<filename>/layouts</filename>
							folder of the project.
						</para>
					</listitem>
					<listitem>
						<para>
							The
							<classname>Rescue</classname>
							attribute tells MonoRail that if any
							unhandled exception is thrown by the an
							action on the
							<classname>HomeController</classname>
							a special
							<emphasis>rescue</emphasis>
							view template called
							<literal>generalerror.vm</literal>
							in the
							<filename>/rescues</filename>
							folder of the project should be rendered.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Layouts and rescues can minimize the amount of work you
				do when building view templates and allow your view
				templates to be better encapsulated.
			</para>
		</section>
		<section>
			<title>Creating the Layout</title>
			<para>
				A
				<emphasis>layout</emphasis>
				defines the outer content of a rendered view and has
				some similarities to a master page. Your project can
				have as many layouts as you like - the layout files
				simply need to be placed into the
				<filename>/layouts</filename>
				folder of the project.
			</para>
			<para>
				Our first layout is very simple, and should be saved as
				<filename>default.vm</filename>
				on the
				<filename>/layouts</filename>
				folder.
			</para>
			<programlisting language="xml"><![CDATA[
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
		<head>
			<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
			<title>Layout</title>
			<link rel="stylesheet" href="$siteRoot/Content/css/base.css" />
		</head>		
	<body>
	
	$childContent
		
	</body>
</html>
]]></programlisting>
			<para>
				At this point some explanation of the template above is
				in order.
			</para>
			<para>
				The
				<varname>$childContent</varname>
				variable defines where the content of the view being
				rendered will be included on the layout.
			</para>
			<para>
				The
				<varname>$siteRoot</varname>
				variable will represent the root of the application. If,
				for example, the web application is using a virtual
				directory it will be the name of the virtual directory.
				Under normal circumstances, however, it will simply
				evaluate to "
				<literal>/</literal>
				" .
			</para>
		</section>
		<section>
			<title>Seeing the Results</title>
			<para>
				If you created the application with the wizard, just hit
				<menuchoice>
					<guimenu>Debug</guimenu>
					<guimenuitem>Start</guimenuitem>
				</menuchoice>
				or
				<keysym>F5</keysym>
				in Visual Studio to start a debug session. On the
				browser, go to the application URL and enter the
				controller name and the action name plus the extension
				you have selected, eg.
				<literal>
					http://localhost:8081/home/index.castle
				</literal>
				. The browser should render the view content with the
				layout applied:
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_exec_1.png" />
					</imageobject>
				</mediaobject>
			</para>
			<para>
				If you view the source of the page in your browser you
				should see well formed XHTML content that includes the
				content defined in the layout as well as the content
				rendered by the view.
			</para>
			<note>
				<para>
					Should you wish to run the application using
					Microsoft Internet Information Services, you must
					associate the extension you selected (i.e.
					<literal>.castle</literal>
					) with the ASP.Net ISAPI. For more information on
					how to do this please see the chapter entitled
					<link linkend="installation"
						endterm="installation.title" />
					.
				</para>
			</note>
		</section>
		<section>
			<title>Passing Values to a View</title>
			<para>
				As shown by the excessively simple view example used
				earlier, views are pretty useless unless you can pass
				custom values to them for rendering at runtime. The main
				mechanism for transferring values from the controller to
				the view is the
				<property>PropertyBag</property>
				.Values placed in the
				<property>PropertyBag</property>
				will be made available to the view template, however
				each view engine will provide access to these values
				differently. Since we're using the NVelocity view engine
				the values in the
				<property>PropertyBag</property>
				will be exposed as NVelocity variables which begin with
				a
				<literal>$</literal>
				symbol in the NVelocity view template.
			</para>
			<para>
				To demonstrate this principle let's create another
				action on our
				<classname>HomeController</classname>
				.
			</para>
			<programlisting language="cs"><![CDATA[
[Layout("default"), Rescue("generalerror")]
public class HomeController : SmartDispatcherController
{
	public void Index()
	{
	}
	
	public void DataToTheView()
	{
		PropertyBag["name"] = "John Doe";
		PropertyBag["today"] = DateTime.Now;
		
		RenderView("data");
	}
}
]]></programlisting>
			<para>
				The new
				<methodname>DataToTheView</methodname>
				action uses the
				<property>PropertyBag</property>
				to pass data to the view. It then invokes the built-in
				<methodname>RenderView</methodname>
				method on the controller to specify that the
				<filename>/views/home/data.vm</filename>
				view template should be rendered instead of the default
				<filename>/views/home/datatotheview.vm</filename>
				template.
			</para>
			<para>
				Now let's create the
				<literal>data.vm</literal>
				template in the
				<literal>\views\home</literal>
				folder.
			</para>
			<programlisting language="nv"><![CDATA[
<h3> Hello $name! </h3>

<h4> Today is $today.ToShortDateString() </h4>
]]></programlisting>
			<para>
				To see the result of the change run the application and
				visit
				<literal>home/datatotheview.castle</literal>
				in your browser.
			</para>
		</section>
		<section>
			<title>Creating a Rescue</title>
			<para>
				In an earlier step we specified that our controller uses
				a
				<emphasis>rescue.</emphasis>
				A rescue is a special purpose view template that will be
				rendered only in the event that an exception is thrown
				while executing an action on a controller. Lets create
				the rescue view to report errors nicely and see how it
				works.
			</para>
			<para>
				First, create a view template named
				<literal>generalerror.vm</literal>
				in the
				<literal>\views\rescues</literal>
				folder with the following content.
			</para>
			<programlisting language="nv"><![CDATA[
#macro(showexception $exc)
<b>$exc.GetType().Name</b>

Message:
$exc.Message

#if($exc.StackTrace)
StackTrace:
$exc.StackTrace
#end

#if($exc.InnerException)
<b>Inner exception:</b>
#set($inner = $exc.InnerException)
#showexception($inner)
#end
#end

<h2>Unexpected error happened</h3>

<p> This is the rescue page. See the exception details below </p>

<pre>
#set($exception = $context.LastException)
#showexception($exception)
</pre>
]]></programlisting>
			<para>
				There's quite a bit of logic in this template, but we
				won't get into the details now. If you want to explore
				these features in more detail see the NVelocity
				documentation.
			</para>
			<para>
				Now let's create a new action that will throw an
				exception so we can see the rescue template in action.
			</para>
			<programlisting language="cs"><![CDATA[
[Layout("default"), Rescue("generalerror")]
public class HomeController : SmartDispatcherController
{
	public void Index()
	{
	}
	
	public void ErroneousAction()
	{
		throw new Exception("I'm a bad bad action.");
	}
	
	public void DataToTheView()
	{
		PropertyBag["name"] = "John Doe";
		PropertyBag["today"] = DateTime.Now;
		
		RenderView("data");
	}
}
]]></programlisting>
			<para>
				If you now run the application and go to
				<literal>home/erroneousaction.castle</literal>
				in your browser the
				<methodname>ErroneousAction</methodname>
				method will throw an exception as we specified and the
				rescue will be displayed.
			</para>
		</section>
	</section>
	<section>
		<title>Data Binding</title>
		<para>
			Although the controller we've been using so far in our
			sample application extends from
			<classname>SmartDispatcherController</classname>
			we haven't yet used any of its more advanced capabilities.
			The
			<classname>SmartDispatcherController</classname>
			base class, as the name implies, provides some "smart"
			functionality, including binding query string values, form
			values and even cookies to the parameters of action methods
			when they are invoked. This includes both simple types and
			custom, complex types as will be discussed in the following
			sections.
		</para>
		<section>
			<title>Simple Parameters</title>
			<para>
				Simple types can be bound to action parameters with no
				special configuration other than to ensure your
				controller is derived from the
				<classname>SmartDispatchController</classname>
				class. For example, suppose you have the following HTML
				form on a view:
			</para>
			<programlisting language="xml"><![CDATA[
<form action="/home/saveinformation.castle" method="post" >
	<input type="text" name="name" value="John doe" />
	<input type="text" name="age" value="30" />
	<input type="text" name="dob" value="07-16-1979" />
	<input type="submit" value="Send" />
</form>
]]></programlisting>
			<para>
				The form action directs the post to the
				<classname>HomeController</classname>
				class'
				<methodname>SaveInformation</methodname>
				action method. This method can be constructed in in such
				a way that it will expect the values from the submitted
				HTML form as parameters:
			</para>
			<programlisting language="cs"><![CDATA[
public class HomeController : SmartDispatcherController
{
	public void Index()
	{
	}
	
	public void SaveInformation(String name, int age, DateTime dob)
	{
		// work work work
		
		// Send the user back to the index 
		RedirectToAction("index");
	}
}
]]></programlisting>
			<para>
				In the above example each of the form fields will be
				data-bound to the method parameter of the same name on
				the
				<methodname>SaveInformation</methodname>
				method.
			</para>
			<para>
				Using this automatic data binding feature reduces the
				effort required to access the values submitted by the
				view. It is still possible to access the values from the
				HTML form without data binding through use of the
				<property>Params</property>
				or
				<property>Form</property>
				name-value collections exposed by the controller,
				however using data binding is cleaner and simpler. The
				code sample below provides the same functionality as the
				example above - we will leave it to you to decide which
				is clearer and easier to use.
			</para>
			<programlisting language="cs"><![CDATA[
public class HomeController : SmartDispatcherController
{
	public void Index()
	{
	}
	
	public void SaveInformation()
	{
		String name = Params["name"];
		int age = Convert.ToInt32(Params["age"]);
		DateTime dob = Convert.ToDateTime(Params["dob"]);
	
		// work work work
		
		// Send the user back to the index 
		RedirectToAction("index");
	}
}
]]></programlisting>
			<para>
				The
				<classname>SmartDispatchController</classname>
				is capable of handling a wide range of built-in .NET
				types. For further details on the types supported refer
				to the documentation on
				<link linkend="controllers.databinding">
					Data Binding
				</link>
				in the
				<link linkend="controllers">Controllers</link>
				chapter.
			</para>
		</section>
		<section>
			<title>Complex Objects</title>
			<para>
				Along with data binding simple value types the
				<classname>SmartDispatcherController</classname>
				provides features to data bind custom and arbitrarily
				complex objects. In order to illustrate how this can be
				achieved we will create a new controller that presents a
				contact form designed to allow a user to contact a
				department in a fictitious company.
			</para>
			<para>
				First, create a new controller named
				<classname>ContactController</classname>
				and add two empty actions;
				<methodname>ContactForm</methodname>
				and
				<methodname>SendContactMessage</methodname>
				.
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Controllers
{
	using System;
	using Castle.MonoRail.Framework;

	[Layout("default"), Rescue("generalerror")]
	public class ContactController : SmartDispatcherController
	{
		public void ContactForm()
		{
		}
		
		public void SendContactMessage()
		{
		}
	}
}
]]></programlisting>
			<para>
				Next, in the
				<filename>/models</filename>
				folder create a class named
				<classname>Contact</classname>
				- this class will be used to represent the contact
				information submitted by the user.
			</para>
			<programlisting language="cs"><![CDATA[
public class Contact
{
	private string from;
	private string area;
	private string subject;
	private string message;

	public string From
	{
		get { return from; }
		set { from = value; }
	}

	public string Area
	{
		get { return area; }
		set { area = value; }
	}

	public string Subject
	{
		get { return subject; }
		set { subject = value; }
	}

	public string Message
	{
		get { return message; }
		set { message = value; }
	}
}
]]></programlisting>
			<para>
				Now create the view to be displayed by the
				<methodname>ContactForm</methodname>
				action. The template file
				<literal>contactform.vm</literal>
				should be created in the
				<filename>\views\contact</filename>
				folder and must contain the following code:
			</para>
			<programlisting language="xml"><![CDATA[
<h2>Contact us!</h2>

<p>
We are interested in hearing from you.
</p>

<form action="contact/sendcontactmessage.castle" method="post">

<p>
From: $FormHelper.TextField("contact.from")
</p>

<p>
Area: $FormHelper.TextField("contact.area") (Sales, Support)
</p>

<p>
Subject: $FormHelper.TextField("contact.subject", "%{size='30'}")
</p>

<p>
Message: <br/> 
$FormHelper.TextArea("contact.message", "%{cols='35', rows='6'}")
</p>

<br />

<p>
<input type="submit" value="Send the message" />
</p>

</form>
]]></programlisting>
			<para>
				In the code above we have made use of the
				<classname>FormHelper</classname>
				helper class to generate an HTML form with the following
				source:
			</para>
			<programlisting language="xml"><![CDATA[
<h2>Contact us!</h2>

<p>
We are interested in hearing from you.
</p>

<form action="contact/sendcontactmessage.castle" method="post">

<p>
From: <input type="text" name="contact.from" />
</p>

<p>
Area: <input type="text" name="contact.area" /> (Sales, Support)
</p>

<p>
Subject: <input type="text" name="contact.subject" size="30" />
</p>

<p>
Message: <br/> 
<input type="textarea" name="contact.message" cols="35" rows="6" />
</p>

<br />

<p>
<input type="submit" value="Send the message" />
</p>

</form>
]]></programlisting>
			<note>
				<para>
					Further information on the
					<link linkend="formhelper">
						<classname>FormHelper</classname>
					</link>
					helper and on helpers in general can be found in the
					chapter entitled
					<link linkend="helpers" endterm="helpers.title" />
					.
				</para>
			</note>
			<para>
				At this point it is important to note that the name of
				each generated field on the HTML form has been prefixed
				with the text
				<literal>contact</literal>
				followed by a dot and then the name of the property of
				the form (eg.
				<literal>contact.from</literal>
				in the case of the "From" field in our example). This
				indicates that each of the fields belong to a single
				group of data that will be bound to an object by the
				data binder.
			</para>
			<para>
				Finally, change the parameters of the
				<methodname>SendContactMessage</methodname>
				action on the
				<classname>ContactController</classname>
				to indicate to the MonoRail binder that it should bind
				the form data prefixed with
				<literal>contact</literal>
				to the
				<classname>Contact</classname>
				class created earlier.
			</para>
			<programlisting language="cs"><![CDATA[
public void SendContactMessage([DataBind("contact")] Contact theContact)
{
	// Pretend to save the contact ...
	
	// ..work work work..
	
	// Now lets add the contact to the property bag
	// so we can render a nice message back to the user
	
	PropertyBag["contact"] = theContact;
	
	RenderView("confirmation");
}
]]></programlisting>
			<para>
				As you can see, a parameter named
				<parameter>theContact</parameter>
				has been added to the
				<methodname>SendContactMethod</methodname>
				action which has been decorated with the
				<classname>DataBindAttribute</classname>
				. The
				<classname>DataBindAttribute</classname>
				has been initialized with a string parameter that tells
				the binder that it should attempt bind the form values
				prefixed with
				<emphasis>"contact."</emphasis>
				to the properties of the
				<parameter>theContact</parameter>
				parameter that share the same name as the part of the
				form element name that appears after the text
				<emphasis>"contact."</emphasis>
				.
			</para>
			<para>
				While we're here we might as well create the
				<literal>confirmation</literal>
				view as well.
			</para>
			<programlisting language="nv"><![CDATA[
<p>

Thanks $!contact.from, we have received your message and will
get back to your shortly.

</p>
]]></programlisting>
			<para>
				Now if you visit
				<literal>/contact/contactform.castle</literal>
				in your browser you should be able to view the results
				of your work. Fill the form elements, submit it and you
				should see the name you submitted in the
				<emphasis>from</emphasis>
				field on the form.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_contact_1.png" />
					</imageobject>
				</mediaobject>
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/gs_contact_2.png" />
					</imageobject>
				</mediaobject>
			</para>
		</section>
	</section>
	<section>
		<title>Integrating with ActiveRecord</title>
		<para>
			In order to explore some more realistic scenarios you will
			face during daily development lets take a look at using
			ActiveRecord for reading and writing data stored in a
			database. The Castle ActiveRecord project is an
			implementation of the ActiveRecord pattern for .NET that
			uses
			<ulink url="http://www.hibernate.org">Nhibernate</ulink>
			to communicate with the database.
		</para>
		<para>
			To add ActiveRecord support to the sample project we will
			reference the required assemblies, set up a database and
			finally configure and initialize ActiveRecord.
		</para>
		<note>
			<para>
				For more information on ActiveRecord see the
				<ulink
					url="http://www.castleproject.org/activerecord/index.html">
					ActiveRecord documentation
				</ulink>
				.
			</para>
		</note>
		<section>
			<title>Adding Assemblies</title>
			<para>
				First, add references to the assemblies required to use
				ActiveRecord in your project :
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<literal>Castle.ActiveRecord.dll</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>Castle.DynamicProxy.dll</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>Iesi.Collections.dll</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>log4net.dll</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>NHibernate.dll</literal>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Configuration</title>
			<para>
				Now we need to add the ActiveRecord configuration
				elements to the
				<filename>web.config</filename>
				in the project.
			</para>
			<programlisting language="xml"><![CDATA[
<configuration>
	<configSections>
		
		...
		
		<section 
			name="activerecord"
			type="Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler, Castle.ActiveRecord" />
	
	</configSections>
	
	<activerecord isWeb="true">
	    
		<config>
			<add 
				key="hibernate.connection.driver_class" 
				value="NHibernate.Driver.SqlClientDriver" />
			<add 
				key="hibernate.dialect"                 
				value="NHibernate.Dialect.MsSql2000Dialect" />
			<add 
				key="hibernate.connection.provider"     
				value="NHibernate.Connection.DriverConnectionProvider" />
			<add 
				key="hibernate.connection.connection_string" 
				value="Data Source=.;Initial Catalog=test;Integrated Security=SSPI" />
		</config>
	    
	</activerecord>
	
	...
]]></programlisting>
			<para>
				The configuration above defines the section handler that
				tells ActiveRecord how to find and interpret the
				ActiveRecord configuration information followed by the
				configuration section itself.
			</para>
			<note>
				<para>
					For our sample we've used SQL Server 2000, however
					since ActiveRecord uses NHibernate it can support
					any database dialect that NHibernate supports. If
					you are using a different database you want to
					change the dialect please refer to the ActiveRecord
					<ulink
						url="http://www.castleproject.org/activerecord/documentation/trunk/manual/xmlconfigref.html">
						Xml Configuration Reference
					</ulink>
					for further information.
				</para>
			</note>
			<para>
				The example configuration section we've defined contains
				information that tells ActiveRecord the type of database
				we're using and specifies the connection string to a
				database named
				<literal>test</literal>
				. You will need to make sure that the database exists or
				will need to change the connection string to specify
				another database.
			</para>
			<warning>
				<para>
					If you change the connection string to another
					database it must already exist and the tables
					required to support the sample project will be added
					to it.
				</para>
			</warning>
		</section>
		<section>
			<title>Building the Model</title>
			<para>
				Next, we'll create two new model classes that will
				represent products and suppliers. The classes should be
				created in the
				<filename>/models</filename>
				folder of the project. First, create the
				<filename>Supplier.cs</filename>
				class to represent the supplier:
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Models
{
	using System;
	using Castle.ActiveRecord;
	using NHibernate.Expression;

	[ActiveRecord]
	public class Supplier : ActiveRecordBase
	{
		private int id;
		private String name;

		[PrimaryKey]
		public int Id
		{
			get { return id; }
			set { id = value; }
		}

		[Property]
		public string Name
		{
			get { return name; }
			set { name = value; }
		}
		
		/// <summary>
		/// Returns the Suppliers ordered by Name
		/// </summary>
		/// <returns>Suppliers array</returns>
		public static Supplier[] FindAll()
		{
			return (Supplier[]) FindAll(typeof(Supplier), new Order[] { Order.Asc("Name") });
		}
	}
}
]]></programlisting>
			<para>
				Then create the
				<filename>Product.cs</filename>
				class to represent the product:
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Models
{
	using System;
	using Castle.ActiveRecord;

	[ActiveRecord]
	public class Product : ActiveRecordBase
	{
		private int id;
		private String name;
		private decimal price;
		private Supplier supplier;

		[PrimaryKey]
		public int Id
		{
			get { return id; }
			set { id = value; }
		}

		[Property]
		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		[Property]
		public decimal Price
		{
			get { return price; }
			set { price = value; }
		}

		[BelongsTo("SupplierId")]
		public Supplier Supplier
		{
			get { return supplier; }
			set { supplier = value; }
		}
		
		public static Product[] FindAll()
		{
			return (Product[]) FindAll(typeof(Product));
		}
		
		public static Product FindById(int id)
		{
			return (Product) FindByPrimaryKey(typeof(Product), id);
		}
	}
}
]]></programlisting>
			<note>
				<para>
					You may notice that the classes have been decorated
					with the
					<literal>[ActiveRecord]</literal>
					attribute and each of their properties have been
					decorated with attributes such as
					<literal>[PrimaryKey]</literal>
					,
					<literal>[Property]</literal>
					and
					<literal>[BelongsTo]</literal>
					. These, and other elements of these classes are
					specific to ActiveRecord; to gain a better
					understanding of these features you should refer to
					the
					<ulink
						url="http://www.castleproject.org/activerecord/index.html">
						ActiveRecord documentation
					</ulink>
					.
				</para>
			</note>
		</section>
		<section>
			<title>Initializing the Handler</title>
			<para>
				The last step is to initialize ActiveRecord. Ideally in
				MonoRail this is done in the class associated with the
				<filename>global.asax</filename>
				file. If no
				<filename>global.asax</filename>
				create it now with the following content:
			</para>
			<programlisting language="xml"><![CDATA[
<%@ Application Inherits="GettingStartedSample.GlobalApplication" %>
]]></programlisting>
			<para>
				Now create the
				<classname>GlobalApplication</classname>
				class the
				<filename>global.asax</filename>
				refers to by adding a
				<filename>GlobalApplication.cs</filename>
				file to the project.
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample
{
	using System;
	using System.Web;
	using Castle.ActiveRecord;
	using Castle.ActiveRecord.Framework.Config;
	using GettingStartedSample.Models;
	

	public class GlobalApplication : HttpApplication
	{
		public GlobalApplication()
		{
		}

		public void Application_OnStart()
		{
			ActiveRecordStarter.Initialize(ActiveRecordSectionHandler.Instance, 
			                               new Type[] { typeof(Supplier), typeof(Product) });
			
			// If you want to let ActiveRecord create the schema for you:
			ActiveRecordStarter.CreateSchema();
		}

		public void Application_OnEnd() 
		{
		}
	}
}
]]></programlisting>
			<para>
				The
				<classname>GlobalApplication</classname>
				class inherits from
				<classname>HttpApplication</classname>
				and implements
				<methodname>Application_OnStart</methodname>
				where code to be executed before the application begins
				for the first time will be located. Into this method we
				have added the
				<literal>ActiveRecordStarter.Initialize</literal>
				method call to initialize ActiveRecord.
			</para>
			<warning>
				<para>
					In the sample above we've added a call to
					<literal>ActiveRecordStarter.CreateSchema</literal>
					which will create the required tables in the
					database to match the ActiveRecord classes defined
					earlier. After the application has been started for
					the first time and the database schema has been
					populated this line should be commented out.
				</para>
			</warning>
		</section>
		<section>
			<title>ActiveRecord Scaffolding</title>
			<para>
				There are several ways of creating the pages that handle
				Create, Retrieve, Update and Delete (CRUD) functionality
				in MonoRail, the simplest of which is using ActiveRecord
				Scaffolding, which works well for prototyping . Since
				this application is simply to demonstrate some of the
				features of MonoRail we will use Scaffolding to get up
				and running quickly, however later we will look at a
				more sophisticated solution that would be more suitable
				for production applications.
			</para>
			<para>
				Enabling ActiveRecord only requires that we add a couple
				of additional assemblies and create a very basic
				controller.
			</para>
			<section>
				<title>Adding Assemblies</title>
				<para>
					First, add references to the assemblies required for
					ActiveRecord Scaffolding support:
					<itemizedlist>
						<listitem>
							<para>
								<literal>
									Castle.MonoRail.ActiveRecordScaffold.dll
								</literal>
							</para>
						</listitem>
						<listitem>
							<para>
								<literal>
									Castle.MonoRail.ActiveRecordSupport.dll
								</literal>
							</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
			<section>
				<title>Creating the Controller</title>
				<para>
					Next, create the controller that will provide the
					CRUD functions for the
					<classname>Supplier</classname>
					class:
				</para>
				<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Controllers
{
	using System;
	using Castle.MonoRail.Framework;
	using GettingStartedSample.Models;

	[Scaffolding(typeof(Supplier))]
	public class SupplierController : Controller
	{
	}
}
]]></programlisting>
				<para>
					You may notice that the controller does not contain
					any code at all. This is because the addition of the
					<classname>ScaffoldingAttribute</classname>
					decoration on the controller class tells MonoRail
					that this is a Scaffolding controller so all the
					additional functionality is automatically provided.
				</para>
			</section>
			<section>
				<title>Viewing the Result</title>
				<para>
					If you use Scaffolding for your CRUD functionality
					that is it - all the features have automatically
					been added. If you visit the url
					<literal>/supplier/list.castle</literal>
					you will see that the list page is automatically
					provided along with all the navigation features and
					links to add, remove and modify supplier data in the
					database.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="images/gs_scaffold_1.png" />
						</imageobject>
						<caption>The supplier list</caption>
					</mediaobject>
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="images/gs_scaffold_2.png" />
						</imageobject>
						<caption>Adding a supplier</caption>
					</mediaobject>
				</para>
			</section>
		</section>
		<section>
			<title>Creating CRUD Pages Using DataBind</title>
			<para>
				In the previous section we looked at the creation of
				basic CRUD pages to access
				<classname>Supplier</classname>
				data using Scaffolding; now we'll look at a more
				flexible approach. In this example we will manually
				create the controller actions and views to provide a
				more sophisticated solution. To keep things simple we'll
				reuse the
				<classname>Supplier</classname>
				and
				<classname>Product</classname>
				model classes we created earlier and will now develop
				the CRUD pages for the
				<classname>Product</classname>
				class.
			</para>
			<para>
				First, create the basis of the
				<classname>ProductController</classname>
				class using the following code:
			</para>
			<programlisting language="cs"><![CDATA[
namespace GettingStartedSample.Controllers
{
	using System;
	using Castle.MonoRail.Framework;
	using GettingStartedSample.Models;

	[Layout("default"), Rescue("generalerror")]
	public class ProductController : SmartDispatcherController
	{
	}
}
]]></programlisting>
			<para>
				Into this controller we will add the action that will
				present the list of products along with the actions that
				control adding, updating and deleting products.
			</para>
			<section>
				<title>Presenting the List</title>
				<para>
					First, lets look at creating the the
					<methodname>List</methodname>
					action on the controller. This action will present a
					list of the
					<classname>Product</classname>
					data from the database.
				</para>
				<programlisting language="cs"><![CDATA[
public void List()
{
	PropertyBag["products"] = Product.FindAll();
}
]]></programlisting>
				<para>
					The call to the static
					<methodname>FindAll</methodname>
					method on the
					<classname>Product</classname>
					in the code above gets all the
					<classname>Product</classname>
					items from the database which are then made
					available to the view by passing them to the
					<property>PropertyBag</property>
					. The
					<methodname>FindAll</methodname>
					method, amongst others, is exposed by the
					<classname>ActiveRecordBase</classname>
					class that we used as the base class for our
					<classname>Product</classname>
					.
				</para>
				<para>
					Next, build the view to go with the
					<methodname>List</methodname>
					action by creating the
					<filename>list.vm</filename>
					file with the following content in the
					<filename>/views/product</filename>
					folder.
				</para>
				<programlisting language="xml"><![CDATA[
<h3>Product list</h3>

<p>
<a href="new.castle">Create new Product</a>
</p>

<table width="100%" border="1" cellpadding="2" cellspacing="0">
<tr>
	<th>Id</th>
	<th>Name</th>
	<th>Supplier</th>
	<th>&nbsp;</th>
</tr>
#foreach($product in $products)
<tr>
	<td align="center">$product.Id</td>
	<td align="center">$product.Name</td>
	<td align="center">$product.Supplier.Name</td>
	<td align="center">
		<a href="edit.castle?id=${product.Id}">Edit</a> | 
		<a href="delete.castle?id=${product.Id}">Delete</a>
	</td>
</tr>
#end
</table>
]]></programlisting>
				<para>
					At this stage you can see the results of the
					<methodname>List</methodname>
					action and view by visiting the
					<literal>/product/list.castle</literal>
					url in your browser.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/gs_crud_2.png" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section>
				<title>Creating</title>
				<para>
					To create a new product we will use two actions; one
					that will present the form on which the user can
					provide the information about the new product and
					another that will store the provided data into the
					database. First, create the
					<methodname>New</methodname>
					action that will present the user with the form.
				</para>
				<programlisting language="cs"><![CDATA[
public void New()
{
	PropertyBag["suppliers"] = Supplier.FindAll();
}
]]></programlisting>
				<para>
					This action, apart from displaying the form to the
					user provides all the existing suppliers available
					to the view so it can populate a select element to
					choose a supplier from.
				</para>
				<para>
					Now add the view associated with the
					<methodname>New</methodname>
					action by creating the
					<literal>new.vm</literal>
					file in the
					<filename>/views/product</filename>
					folder and populate it with the following content:
				</para>
				<programlisting language="xml"><![CDATA[
<h3>New Product</h3>

#if($Flash.error)
<p style="color: red; font-weight: bold;">
	$Flash.error
</p>
#end

<form action="create.castle" method="post">

	<p>
	Name: $FormHelper.TextField("product.name")
	</p>

	<p>
	Price: $FormHelper.TextFieldFormat("product.price", "000.00")
	</p>

	<p>
	Supplier: $FormHelper.Select("product.supplier.id", $suppliers, "%{value='Id', text='Name'}")
	</p>

	<hr/>

	<p>
	<input type="submit" value="Create" />
	</p>

</form>
]]></programlisting>
				<para>
					Finally, add the
					<methodname>Create</methodname>
					action to handle the data submitted from the form by
					the user.
				</para>
				<programlisting language="cs"><![CDATA[
public void Create([DataBind("product")] Product prod)
{
	try
	{
		prod.Create();
	
		RedirectToAction("list");
	}
	catch(Exception ex)
	{
		Flash["error"] = ex.Message;
		Flash["product"] = prod;
		
		RedirectToAction("new");
	}
}
]]></programlisting>
				<para>
					This method is using data binding to bind the form
					data into the
					<parameter>prod</parameter>
					parameter which then uses the
					<methodname>Create</methodname>
					method from the
					<classname>ActiveRecordBase</classname>
					base class of the
					<classname>Product</classname>
					class. The
					<methodname>Create</methodname>
					method will add the
					<classname>Product</classname>
					into the database. Once the
					<classname>Product</classname>
					has been created this action will redirect the user
					back to the
					<methodname>List</methodname>
					action created earlier.
				</para>
				<para>
					You can now test your work by accessing the
					<methodname>New</methodname>
					action using the
					<literal>/product/new.castle</literal>
					url.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/gs_crud_1.png" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section>
				<title>Updating</title>
				<para>
					Building the update functionality is very similar to
					the process used when building the create feature.
					Again there will be two actions; one that presents a
					form for editing a
					<classname>Product</classname>
					and another for saving the changes after the form
					has been submitted.
				</para>
				<para>
					First, create the two actions for edit and update:
				</para>
				<programlisting language="cs"><![CDATA[
public void Edit(int id)
{
	PropertyBag["product"] = Product.FindById(id);
	PropertyBag["suppliers"] = Supplier.FindAll();
}

public void Update([DataBind("product")] Product prod)
{
	try
	{
		prod.Update();
	
		RedirectToAction("list");
	}
	catch(Exception ex)
	{
		Flash["error"] = ex.Message;
		Flash["product"] = prod;
		
		RedirectToAction("edit", "id=" + prod.Id);
	}
}
]]></programlisting>
				<para>
					The
					<methodname>Edit</methodname>
					action will present the form to the user and provide
					all the relevant data to the form. The
					<methodname>Update</methodname>
					action will handle saving the changes submitted by
					the user and redirecting the ser back to the
					<methodname>List</methodname>
					action.
				</para>
				<para>
					We can also overload the
					<methodname>Edit</methodname>
					action method. This overload will be used
					specifically when an error is caught by the
					<methodname>Update</methodname>
					action. In the catch handler the action redirects
					the user back to the edit page so they can correct
					any errors. Also of note is the
					<classname>FlashBinder</classname>
					which allows you to bind data to parameters from the
					<classname>Flash</classname>
					rather than from Request or Post data.
				</para>
				<programlisting language="cs"><![CDATA[
public void Edit(int id, [FlashBinder] Product product)
{
	PropertyBag["suppliers"] = Supplier.FindAll();
}
]]></programlisting>
				<para>
					Next, we'll create the edit view. The
					<literal>edit.vm</literal>
					template is very similar to the
					<literal>new.vm</literal>
					template created in the last section; it will be
					responsible for displaying the form for editing the
					product.
				</para>
				<programlisting language="xml"><![CDATA[
<h3>Edit Product</h3>

#if($Flash.error)
<p style="color: red; font-weight: bold;">
	$Flash.error
</p>
#end

<form action="update.castle" method="post">

$FormHelper.HiddenField("product.id")

	<p>
	Name: $FormHelper.TextField("product.name")
	</p>

	<p>
	Price: $FormHelper.TextFieldFormat("product.price", "000.00")
	</p>

	<p>
	Supplier: $FormHelper.Select("product.supplier.id", $suppliers, "%{value='Id', text='Name'}")
	</p>

	<hr/>

	<p>
	<input type="submit" value="Update" />
	</p>

</form>
]]></programlisting>
				<para>
					In the code above we've used the
					<classname>FormHelper</classname>
					which is clever enough to populate the fields and
					select the correct item on the form's
					<literal>select</literal>
					element.
				</para>
			</section>
			<section>
				<title>Deleting</title>
				<para>
					The last in our CRUD series, the delete step is the
					easiest one; simply add the
					<methodname>Delete</methodname>
					action to the controller with the following code.
				</para>
				<programlisting language="cs"><![CDATA[
public void Delete(int id)
{
	Product product = Product.FindById(id);
	
	product.Delete();
	
	RedirectToAction("list");
}
]]></programlisting>
				<para>
					This action will be called when the user clicks the
					<emphasis>delete</emphasis>
					link on the list page. It gets the if of the product
					using automatic data-binding, finds the product,
					deletes it and redirects back to the list page.
				</para>
			</section>
		</section>
	</section>
	<section>
		<title>Final Comments</title>
		<para>
			The Getting Started chapter gave you a very quick
			introduction to many of MonoRail's features and and how to
			use them, however there is much more to learn. To get a
			better feel for MonoRail you can explore the samples, try
			some experiments of your own, and consult documentation on
			the various features covered here for much more in-depth
			information.
		</para>
	</section>
</chapter>