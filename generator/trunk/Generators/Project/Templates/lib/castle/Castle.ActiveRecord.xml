<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.ActiveRecord</name>
    </assembly>
    <members>
        <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor">
            <summary>
            Initializes a new credit card validator.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(System.String)">
            <summary>
            Initializes a new credit card validator.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType)">
            <summary>
            Initializes a new credit card validator.
            </summary>
            <param name="allowedTypes">The card types to accept.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType,System.String)">
            <summary>
            Initializes a new credit card validator.
            </summary>
            <param name="allowedTypes">The card types to accept.</param>
            <param name="errorMessage">The error message to be displayed if the validation fails.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new credit card validator.
            </summary>
            <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(System.String[],System.String)">
            <summary>
            Initializes a new credit card validator.
            </summary>
            <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
            <param name="errorMessage">The error message to be displayed if the validation fails.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType,System.String[])">
            <summary>
            Initializes a new credit card validator.
            </summary>
            <param name="allowedTypes">The card types to accept.</param>
            <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType,System.String[],System.String)">
            <summary>
            Initializes a new credit card validator.
            </summary>
            <param name="allowedTypes">The card types to accept.</param>
            <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
            <param name="errorMessage">The error message to be displayed if the validation fails.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateLengthAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new exact length validator.
            </summary>
            <param name="exactLength">The exact length required.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateLengthAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new exact length validator.
            </summary>
            <param name="exactLength">The exact length required.</param>
            <param name="errorMessage">The error message to be displayed if the validation fails.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateLengthAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new range based length validator.
            </summary>
            <param name="minLength">The minimum length, or <c>int.MinValue</c> if this should not be tested.</param>
            <param name="maxLength">The maximum length, or <c>int.MaxValue</c> if this should not be tested.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateLengthAttribute.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Initializes a new range based length validator.
            </summary>
            <param name="minLength">The minimum length, or <c>int.MinValue</c> if this should not be tested.</param>
            <param name="maxLength">The maximum length, or <c>int.MaxValue</c> if this should not be tested.</param>
            <param name="errorMessage">The error message to be displayed if the validation fails.</param>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordAttribute">
            <summary>
            Associate meta information related to the
            desired table mapping.
            </summary>
            <example>
            <code>
            [ActiveRecord("tb_Order")]
            public class Order : ActiveRecordBase
            {
            }
            </code>
            </example>
            <remarks>
            If no table is specified, the class name 
            is used as table name
            </remarks>
        </member>
        <member name="T:Castle.ActiveRecord.BaseAttribute">
            <summary>
            Implement common properties shared by some
            attributes
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor">
            <summary>
            Uses the class name as table name
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor(System.String)">
            <summary>
            Associates the specified table with the target type
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor(System.String,System.String)">
            <summary>
            Associates the specified table and schema with the target type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Table">
            <summary>
            Gets or sets the table name associated with the type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Schema">
            <summary>
            Gets or sets the schema name associated with the type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Proxy">
            <summary>
            Associates a proxy type with the target type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorColumn">
            <summary>
            Gets or sets the Discriminator column for
            a table inheritance modeling
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorType">
            <summary>
            Gets or sets the column type (like string or integer)
            for the discriminator column
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorValue">
            <summary>
            Gets or sets the value that represents the
            target class on the discriminator column
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Where">
            <summary>
            SQL condition to retrieve objects
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Lazy">
            <summary>
            Enable lazy loading for the type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DynamicUpdate">
            <summary>
            Specifies that UPDATE SQL should be generated at runtime and contain only those columns whose values have changed.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DynamicInsert">
            <summary>
            Specifies that INSERT SQL should be generated at runtime and contain only the columns whose values are not null.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordSkipAttribute">
            <summary>
            Denotes that the specific class - 
            which is an <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/> subclass
            should not be processed by the framework
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Any">
            <summary>
            Avoids the AnyAttribute.MetaValue problem
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.CascadeEnum">
            <summary>
            Defines the cascading behaviour of this association.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CascadeEnum.None">
            <summary> No cascading. This is the default. </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CascadeEnum.All">
            <summary> Cascade save, update and delete. </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CascadeEnum.SaveUpdate">
            <summary> Cascade save and update. </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CascadeEnum.Delete">
            <summary> Cascade delete. </summary>
        </member>
        <member name="T:Castle.ActiveRecord.BelongsToAttribute">
            <summary>
            Maps a one to one association.
            </summary>
            <example>
            <code>
            public class Post : ActiveRecordBase
            {
            		...
            
            		[BelongsTo("blogid")]
            		public Blog Blog
            		{
            		get { return _blog; }
            		set { _blog = value; }
            		}
            	</code>
            </example>
            <remarks>
            Please note that the 'blogid' foreign key lies on the 'Post' table.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.BelongsToAttribute.#ctor(System.String)">
            <summary>
            Indicates the name of the column to be used on the association.
            Usually the name of the foreign key field on the underlying database.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Type">
            <summary>
            Defines the target type of the association. It's usually inferred from the property type.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Column">
            <summary>
            Defines the column used by association (usually a foreign key)
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.CompositeKeyColumns">
            <summary>
            Defines the Composite Key columns used by association (aka Natural Keys).
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Cascade">
            <summary>
            Defines the cascading behavior of this association.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.OuterJoin">
            <summary>
            Defines the outer join behavior of this association.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Update">
            <summary>
            Defines whether this association will be included in database UPDATEs or not.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Insert">
            <summary>
            Defines whether this association will be included in database INSERTs or not.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.NotNull">
            <summary>
            Indicates whether this association allows nulls or not.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Unique">
            <summary>
            Indicates whether this association is unique.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.CollectionIDAttribute">
            <summary>
            Used for a collection that requires a collection id.
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasManyAndBelongs/HasMany]
            	[CollectionIDAttribute(CollectionIDAttribute.Native)]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code></example>
        </member>
        <member name="T:Castle.ActiveRecord.CompositeKeyAttribute">
            <summary>
            Decorates a class that implements <c>Equals()</c> and <c>GetHashCode()</c>,
            is <c>Serializable</c>,
            and has two or more <c>KeyPropertyAttribute</c> properties.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.FieldAttribute">
            <summary>
            Maps a standard column of the table.
            </summary>
            <example>
            In the following example, the column is also
            called 'name', so you don't have to specify.
            <code>
            public class Blog : ActiveRecordBase
            {
            	[Field]
            	string name;
            	
            	
            </code>
            </example>
        </member>
        <member name="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute">
            <summary>
            Maps a many to many association with an association table.
            </summary>
            <example><code>
            public class Company : ActiveRecordBase
            {
              ...
              
              [HasAndBelongsToMany( typeof(Person), RelationType.Bag, Table="PeopleCompanies", Column="person_id", ColumnKey="company_id" )]
              public IList People
              {
              	get { return _people; }
              	set { _people = value; }
              }
            }
            </code></example>
            <remarks>The <see cref="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.ColumnKey"/> must specify the key on the 
            association table that points to the primary key of this class. In 
            the example, 'company_id' points to 'Company'.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Sort">
            <summary>
            Only used with sets
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Index">
            <summary>
            Only used with maps
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.IndexType">
            <summary>
            Only used with maps
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Element">
            <summary>
            Use for simple types.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.HasManyAttribute">
            <summary>
            Maps a one to many association.
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasMany(typeof(Post), RelationType.Bag, Key="Posts", Table="Posts", Column="blogid")]
            	public IList Posts
            	{
            		get { return _posts; }
            		set { _posts = value; }
            	}
            </code></example>
        </member>
        <member name="T:Castle.ActiveRecord.HiloAttribute">
            <summary>
            Used when a constraint requires a hilo algorithm 
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasManyAndBelongs/HasMany,
            	CollectionID(CollectionIDAttribute.HiLo),
            	Hilo]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code></example>
        </member>
        <member name="T:Castle.ActiveRecord.JoinedBaseAttribute">
            <summary>
            Denotes that a class is the parent class of one or 
            more subclasses using a join
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.JoinedKeyAttribute">
            <summary>
            Used for joined subclasses.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.KeyPropertyAttribute">
            <summary>
            A key property for a composite key
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.PropertyAttribute">
            <summary>
            Maps a standard column of the table.
            </summary>
            <example>
            In the following example, the column is also
            called 'name', so you don't have to specify.
            <code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[Property]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            </code>
            To map a column name, use 
            <code>
            	[Property("blog_name")]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            </code>
            </example>
        </member>
        <member name="T:Castle.ActiveRecord.NestedAttribute">
            <summary>
            Maps properties of a child object to columns of the table 
            of a parent class.
            </summary>
            <example>
            The following code illustrates the use of a 
            nested <c>PostalAddress</c> class
            <code>
            	[ActiveRecord("Companies")]
            	public class Company : ActiveRecordBase
            	{
            		private int id;
            		private PostalAddress _address;
            	
            		public Company()
            		{
            		}
            	
            		public Company(string name)
            		{
            			this.name = name;
            		}
            	
            		[PrimaryKey]
            		public int Id
            		{
            			get { return id; }
            			set { id = value; }
            		}
            	
            		[Nested]
            		public PostalAddress Address
            		{
            			get { return _address; }
            			set { _address = value; }
            		}
            	}
            	
            	public class PostalAddress
            	{
            		private String _address;
            		private String _city;
            		private String _state;
            		private String _zipcode;
            	
            		[Property]
            		public String Address
            		{
            			get { return _address; }
            			set { _address = value; }
            		}
            	
            		[Property]
            		public String City
            		{
            			get { return _city; }
            			set { _city = value;}
            		}
            	
            		[Property]
            		public String State
            		{
            			get { return _state; }
            			set { _state = value; }
            		}
            	
            		[Property]
            		public String ZipCode
            		{
            			get { return _zipcode; }
            			set { _zipcode = value; }
            		}
            	}
            </code>
            </example>
        </member>
        <member name="T:Castle.ActiveRecord.OneToOneAttribute">
            <summary>
            Associates a foreign table where the current class
            and the target class share their primary key.
            </summary>
            <example>
            The following code exemplifies two classes that maps 
            to two tables sharing the primary key:
            <code>
            	[ActiveRecord("Employee")]
            	public class Employee : ActiveRecordBase
            	{
            		private int id;
            		private Award award;
            	
            		[PrimaryKey(PrimaryKeyType.Native, "EmployeeID")]
            		public int ID
            		{
            			get { return this.id; }
            			set { this.id = value; }
            		}
            	
            		[OneToOne]
            		public Award Award
            		{
            			get { return this.award; }
            			set { this.award = value; }
            		}
            	}
            	
            	[ActiveRecord("Award")]
            	public class Award : ActiveRecordBase
            	{
            		private Employee employee;
            		private int id;
            	
            		public Award()
            		{
            		}
            	
            		public Award(Employee employee)
            		{
            			this.employee = employee;
            		}
            	
            		[OneToOne]
            		public Employee Employee
            		{
            			get { return this.employee; }
            			set { this.employee = value; }
            		}
            	
            		[PrimaryKey(PrimaryKeyType.Foreign, "EmployeeID")]
            		public int ID
            		{
            			get { return this.id; }
            			set { this.id = value; }
            		}
            	
            		public static Award[] FindAll()
            		{
            			return ((Award[]) (ActiveRecordBase.FindAll(typeof(Award))));
            		}
            	
            		public static void DeleteAll()
            		{
            			ActiveRecordBase.DeleteAll( typeof(Award) );
            		}
            	}
            	Employee emp = new Employee();
            	emp.Name = "john doe";
            	emp.Save();
            	
            	Award award = new Award(emp);
            	award.Description = "Invisible employee";
            	award.Save();
            </code>
            </example>
            <remarks>
            Usually classes that uses the primary key
            generated elsewhere (foreign) uses the PrimaryKey attribute with the
            generator type <c>PrimaryKeyType.Foreign</c>
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.OneToOneAttribute.MapType">
            <summary>
            Allows one to reference a different type
            than the property type
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.PrimaryKeyAttribute">
            <summary>
            Indicates the property which is the primary key.
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[PrimaryKey(PrimaryKeyType.Native)]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code></example>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Params">
            <summary>
            Comma separated value of parameters to the generator
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler">
            <summary>
            Reads the configuration from a entry 'activerecord'
            in the xml associated with the AppDomain
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource">
            <summary>
            Source of configuration based on Xml 
            source like files, streams or readers.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource">
            <summary>
            Usefull for test cases.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.IConfigurationSource">
            <summary>
            Abstracts the source of configuration for the framework.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IConfigurationSource.GetConfiguration(System.Type)">
            <summary>
            Implementors should return an <see cref="T:Castle.Model.Configuration.IConfiguration"/> 
            instance
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.ThreadScopeInfoImplementation">
            <summary>
            Implementors should return the type that implements
            the interface <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.SessionFactoryHolderImplementation">
            <summary>
            Implementors should return the type that implements 
            the interface <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Register(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Internally used
            </summary>
            <param name="arType"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.GetModel(System.Type)">
            <summary>
            Internally used
            </summary>
            <param name="arType"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Key">
            <summary>
            Used only by joined subclasses
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config">
            <summary>
            I need this class to pass special configuration for the many-to-any
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor">
            <summary>
            Connects <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/> with their parents 
            <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/>
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor">
            <summary>
            Traverse the tree checking the semantics of the relation and
            association. The goal is to raise clear exceptions if tips of how 
            to fix any error.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor">
            <summary>
            Traverse the tree emitting proper xml configuration
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.IQueryModifier">
            <summary>
            Any object which intent to change a NHibernate query must implement
            this interface.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.IQueryModifier.Apply(NHibernate.IQuery)">
            <summary>
            Applies this modifier to the query.
            </summary>
            <param name="query">The query</param>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter">
            <summary>
            Represents a query parameter.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Collections.ICollection,NHibernate.Type.IType)">
            <remarks>
            It is important to keep this constructor as is, to avoid
            confusion with the <see cref="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object,NHibernate.Type.IType)"/>
            overload.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Collections.ICollection)">
            <remarks>
            It is important to keep this constructor as is, to avoid
            confusion with the <see cref="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object)"/>
            overload.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Apply(NHibernate.IQuery)">
            <summary>
            Add this parameter to the <paramref name="query"/>.
            </summary>
            <param name="query">The query</param>
            <remarks>
            Is there a cleaner way to do this, without reflection or complex
            hierarchies?
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Position">
            <summary>
            The position of the positional parameter, or <c>-1</c>
            if this is a named parameter.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Name">
            <summary>
            The name of the named parameter, or <c>null</c>
            if this is a positional parameter.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Value">
            <summary>
            The parameter value.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Type">
            <summary>
            The NHibernate type.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.QueryRange">
            <summary>
            Limits a query to the specified results.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordBaseQuery">
            <summary>
            Base class for all ActiveRecord queries.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.IActiveRecordQuery">
            <summary>
            Represents an ActiveRecord Query.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.InternalExecute(NHibernate.ISession)">
            <summary>
            Simply creates the query and then call its <see cref="M:NHibernate.IQuery.List"/> method.
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.InternalEnumerate(NHibernate.ISession)">
            <summary>
            Simply creates the query and then call its <see cref="M:NHibernate.IQuery.Enumerable"/> method.
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.CreateQuery(NHibernate.ISession)">
            <summary>
            Creates the <see cref="T:NHibernate.IQuery"/> instance.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.Clone">
            <summary>
            Just a default clone implementation...
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.AddModifier(Castle.ActiveRecord.Queries.Modifiers.IQueryModifier)">
            <summary>
            Adds a query modifier, to be applied with <see cref="M:Castle.ActiveRecord.ActiveRecordBaseQuery.ApplyModifiers(NHibernate.IQuery)"/>.
            </summary>
            <param name="modifier">The modifier</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.ApplyModifiers(NHibernate.IQuery)">
            <summary>
            Applies the modifiers added with <see cref="M:Castle.ActiveRecord.ActiveRecordBaseQuery.AddModifier(Castle.ActiveRecord.Queries.Modifiers.IQueryModifier)"/>.
            </summary>
            <param name="query">The query in which to apply the modifiers</param>
            <remarks>
            This method is not called automatically 
            by <see cref="T:Castle.ActiveRecord.ActiveRecordBaseQuery"/>, but is called from
            <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery"/>.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.GetResultsArray(System.Type,System.Collections.IList,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IList"/> to an
            strongly-typed array.
            </summary>
            <param name="t">The type of the new array</param>
            <param name="list">The source list</param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.GetResultsArray(System.Type,System.Collections.IList,System.Int32,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IList"/> to an
            strongly-typed array.
            </summary>
            <param name="t">The type of the new array</param>
            <param name="list">The source list</param>
            <param name="entityIndex">
            If the HQL clause selects more than one field, or a join is performed
            without using <c>fetch join</c>, the contents of the result list will
            be of type <c>object[]</c>. Specify which index in this array should be used to
            compose the new result array. Use <c>-1</c> to ignore this parameter.
            </param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.HqlBasedQuery">
            <summary>
            Base class for all HQL-based queries.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.Count">
            <summary>
            Tries to obtain the record count for the current query.
            </summary>
            <returns>The record count for the current query, or <c>-1</c> if failed.</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.HqlBasedQuery.Query">
            <summary>
            The query text.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.IActiveRecordQuery`1">
            <summary>
            Represents an ActiveRecord Query.
            </summary>
            <typeparam name="T">The resulting object type</typeparam>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.InternalExecute(NHibernate.ISession)">
            <summary>
            Executes the query and returns its scalar result.
            </summary>
            <param name="session">The NHibernate's <see cref="T:NHibernate.ISession"/></param>
            <returns>The query's scalar result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.InternalEnumerate(NHibernate.ISession)">
            <summary>
            Creates a single-position object array containing 
            the query's scalar result.
            </summary>
            <param name="session">The NHibernate's <see cref="T:NHibernate.ISession"/></param>
            <returns>An <c>object[1]</c> containing the query's scalar result.</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ScalarQuery`1">
            <summary>
            Represents a query that can result in a value
            of the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The resulting object type</typeparam>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="hql"/>,
            using the specified positional <paramref name="positionalParameters"/> and
            the target ActiveRecord type specified in <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="hql">The HQL</param>
            <param name="positionalParameters">The positional positionalParameters</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,System.String)">
            <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="hql"/> and
            the target ActiveRecord type specified in <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="hql">The HQL</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.Execute">
            <summary>
            Executes the query and gets the result.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.SimpleQuery">
            <summary>
            Simple query.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.InternalExecute(NHibernate.ISession)">
            <summary>
            Executes the query and converts the results into a strongly-typed
            array of <see cref="F:Castle.ActiveRecord.Queries.SimpleQuery.returnType"/>.
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.SimpleQuery`1">
            <summary>
            Represents a query that can result in an array of 
            objects of the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The resulting object type</typeparam>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="hql"/>,
            using the specified positional <paramref name="positionalParameters"/>.
            The target ActiveRecord type is <typeparamref name="T"/>.
            </summary>
            <param name="hql">The HQL</param>
            <param name="positionalParameters">The positional positionalParameters</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="hql"/>,
            using the specified positional <paramref name="positionalParameters"/> and
            the target ActiveRecord type specified in <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="hql">The HQL</param>
            <param name="positionalParameters">The positional positionalParameters</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.Execute">
            <summary>
            Executes the query and gets the results.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.Enumerate">
            <summary>
            Enumerates the query results. Better suited for queries 
            which might return large results.
            <seealso cref="M:NHibernate.IQuery.Enumerable"/>
            </summary>
            <remarks>
            It might not look obvious at first, but 
            <see cref="T:Castle.ActiveRecord.ActiveRecordMediator"/> will call our 
            <see cref="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalEnumerate(NHibernate.ISession)"/>, which will call our 
            <see cref="M:Castle.ActiveRecord.Queries.SimpleQuery`1.GenericEnumerate(NHibernate.ISession)"/>, which will convert
            the <c>NHibernate</c>'s <see cref="M:NHibernate.IQuery.Enumerable"/> result
            returned by <see cref="M:Castle.ActiveRecord.ActiveRecordBaseQuery.InternalEnumerate(NHibernate.ISession)"/>
            into a generic <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            So, all we need to do is to cast it back to <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalEnumerateFromBase(NHibernate.ISession)">
            <summary>
            Needed to avoid <c>CS1911</c>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalExecute(NHibernate.ISession)">
            <summary>
            Executes the query and converts the results into a strongly-typed
            array of <typeparamref name="T"/>.
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.AbstractScope">
            <summary>
            Abstract <seealso cref="T:Castle.ActiveRecord.ISessionScope"/> implementation
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ISessionScope">
            <summary>
            Contract for implementation of scopes.
            </summary>
            <remarks>
            A scope can implement a logic that affects 
            AR for the scope lifetime. Session cache and
            transaction are the best examples, but you 
            can create new scopes adding new semantics.
            <para>
            The methods on this interface are mostly invoked
            by the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            implementation
            </para>
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.RegisterSession(System.Object,NHibernate.ISession)">
            <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            just created one. So it registers the session created 
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it 
            <seealso cref="M:Castle.ActiveRecord.ISessionScope.IsKeyKnown(System.Object)"/>
            </summary>
            <param name="key">an object instance</param>
            <param name="session">An instance of <c>ISession</c></param>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.IsKeyKnown(System.Object)">
            <summary>
            This method is invoked when the 
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key. 
            <seealso cref="M:Castle.ActiveRecord.ISessionScope.RegisterSession(System.Object,NHibernate.ISession)"/>
            </summary>
            <param name="key">an object instance</param>
            <returns><c>true</c> if the key exists within this scope instance</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.GetSession(System.Object)">
            <summary>
            This method should return the session instance associated with the key.
            </summary>
            <param name="key">an object instance</param>
            <returns>the session instance or null if none was found</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo">
            <summary>
            Base <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> implementation. It's up 
            to derived classes to provide a correct implementation 
            of <c>CurrentStack</c> only
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope">
            <summary>
            Still very experimental and it's not bullet proof
            for all situations
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.PerformDisposal(System.Collections.ICollection)">
            <summary>
            </summary>
            <param name="sessions"></param>
        </member>
        <member name="T:Castle.ActiveRecord.SessionScope">
            <summary>
            Implementation of <see cref="T:Castle.ActiveRecord.ISessionScope"/> to 
            augment performance by caching the session, thus
            avoiding too much opens/flushes/closes.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor">
            <summary>
            Class to allow scopes to reach the implementation
            of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>. Also implements 
            the <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> delegating the calls to 
            the scope set.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.TransactionMode">
            <summary>
            Defines the transaction scope behavior
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.TransactionMode.Inherits">
            <summary>
            Inherits a transaction previously create on 
            the current context.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.TransactionMode.New">
            <summary>
            Always create an isolated transaction context.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.TransactionScope">
            <summary>
            Implementation of <see cref="T:Castle.ActiveRecord.ISessionScope"/> to 
            provide transaction semantics
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.WebThreadScopeInfo">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Validators.AbstractValidator">
            <summary>
            Abstract <see cref="T:Castle.ActiveRecord.Framework.IValidator"/> implementation
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.IValidator">
            <summary>
            Define the basic contract for validators
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IValidator.Initialize(System.Reflection.PropertyInfo)">
            <summary>
            Implementors should perform any initialization logic
            </summary>
            <param name="property">The target property</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IValidator.Perform(System.Object)">
            <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
            <param name="instance"></param>
            <returns><c>true</c> if the field is OK</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IValidator.Perform(System.Object,System.Object)">
            <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
            <param name="instance"></param>
            <param name="fieldValue"></param>
            <returns><c>true</c> if the field is OK</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IValidator.Property">
            <summary>
            The target property
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IValidator.ErrorMessage">
            <summary>
            The error message to be displayed if the validation fails
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Initialize(System.Reflection.PropertyInfo)">
            <summary>
            Implementors should perform any initialization logic
            </summary>
            <param name="property">The target property</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Perform(System.Object)">
            <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
            <param name="instance"></param>
            <returns><c>true</c> if the field is OK</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Perform(System.Object,System.Object)">
            <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
            <param name="instance"></param>
            <param name="fieldValue"></param>
            <returns><c>true</c> if the field is OK</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Property">
            <summary>
            The target property
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Validators.AbstractValidator.ErrorMessage">
            <summary>
            The error message to be displayed if the validation fails
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Validators.CreditCardValidator">
            <summary>
            Ensures that a property's string 
            representation is within the desired length limitations.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType)">
            <summary>
            Initializes a new credit card validator.
            </summary>
            <param name="allowedTypes">The card types to accept.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.#ctor(System.String[])">
            <summary>
            Initializes a new credit card validator.
            </summary>
            <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType,System.String[])">
            <summary>
            Initializes a new credit card validator.
            </summary>
            <param name="allowedTypes">The card types to accept.</param>
            <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Validators.EmailValidator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Validators.EmailValidator.emailRule">
            <summary>
            From http://www.codeproject.com/aspnet/Valid_Email_Addresses.asp
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Validators.LengthValidator">
            <summary>
            Ensures that a property's string representation 
            is within the desired length limitations.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.LengthValidator.#ctor(System.Int32)">
            <summary>
            Initializes a new exact length validator.
            </summary>
            <param name="exactLength">The exact length required.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.LengthValidator.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new range based length validator.
            </summary>
            <param name="minLength">The minimum length, or <c>int.MinValue</c> if this should not be tested.</param>
            <param name="maxLength">The maximum length, or <c>int.MaxValue</c> if this should not be tested.</param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Validators.NullCheckValidator">
            <summary>
            Ensures that a property was 
            filled with some value
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.NHibernateDelegate">
            <summary>
            Allow custom executions using the NHibernate's ISession.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordBase">
            <summary>
            Base class for all ActiveRecord classes. Implements 
            all the functionality to simplify the code on the 
            subclasses.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordHooksBase">
            <summary>
            Base class for ActiveRecord entities
            that are interested in NHibernate's hooks.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeSave(System.Collections.IDictionary)">
            <summary>
            Hook to change the object state
            before saving it.
            </summary>
            <param name="state"></param>
            <returns>Return <c>true</c> if you have changed the state. <c>false</c> otherwise</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeLoad(System.Collections.IDictionary)">
            <summary>
            Hook to transform the read data 
            from the database before populating 
            the object instance
            </summary>
            <param name="adapter"></param>
            <returns>Return <c>true</c> if you have changed the state. <c>false</c> otherwise</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeDelete(System.Collections.IDictionary)">
            <summary>
            Hook to perform additional tasks 
            before removing the object instance representation
            from the database.
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.PreFlush">
            <summary>
            Called before a flush
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.PostFlush">
            <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.IsUnsaved">
            <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
            <remarks>
            The return value determines if the object is saved
            <list>
            	<item><c>true</c> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item>
            	<item><c>false</c> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item>
            	<item><c>null</c> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item>
            </list>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.FindDirty(System.Object,System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Type.IType[])">
            <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
            <remarks>
            	<list>
            		<item>an array of property indicies - the entity is dirty</item>
            		<item>an empty array - the entity is not dirty</item>
            		<item><c>null</c> - use Hibernate's default dirty-checking algorithm</item>
            	</list>
            </remarks>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="currentState"></param>
            <param name="types"></param>
            <returns>An array of dirty property indicies or <c>null</c> to choose default behavior</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnSave">
            <summary>
            Lifecycle method invoked during Save of the entity
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnUpdate">
            <summary>
            Lifecycle method invoked during Update of the entity
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnDelete">
            <summary>
            Lifecycle method invoked during Delete of the entity
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnLoad(System.Object)">
            <summary>
            Lifecycle method invoked during Load of the entity
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.#ctor">
            <summary>
            Constructs an ActiveRecordBase subclass.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Register(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Internally used
            </summary>
            <param name="arType"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.GetModel(System.Type)">
            <summary>
            Internally used
            </summary>
            <param name="arType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Create(System.Object)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Delete(System.Object)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Refresh(System.Object)">
            <summary>
            Refresh the instance from the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAll(System.Type,System.Collections.IEnumerable)">
            <summary>
            Deletes all <paramref name="targetType" /> objects, based on the primary keys
            supplied on <paramref name="pkValues" />.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="pkValues">A list of primary keys</param>
            <returns>The number of objects deleted</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Update(System.Object)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Save(System.Object)">
            <summary>
            Saves the instance to the database
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Execute(System.Type,Castle.ActiveRecord.NHibernateDelegate,System.Object)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="targetType">The target ActiveRecordType</param>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.CountAll(System.Type)">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <example>
            <code>
            [ActiveRecord]
            public class User : ActiveRecordBase
            {
              ...
              
              public static int CountAllUsers()
              {
                return CountAll(typeof(User));
              }
            }
            </code>
            </example>
            <param name="targetType">Type of the target.</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.CountAll(System.Type,System.String,System.Object[])">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <example>
            <code>
            [ActiveRecord]
            public class User : ActiveRecordBase
            {
              ...
              
              public static int CountAllUsersLocked()
              {
                return CountAll(typeof(User), "IsLocked = ?", true);
              }
            }
            </code>
            </example>
            <param name="targetType">Type of the target.</param>
            <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
            <param name="args">Positional parameters for the filter string</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type)">
            <summary>
            Check if there is any records in the db for the target type
            </summary>
            <param name="targetType">Type of the target.</param>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,System.String,System.Object[])">
            <summary>
            Check if there is any records in the db for the target type
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
            <param name="args">Positional parameters for the filter string</param>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type)">
            <summary>
            Returns all instances found for the specified type.
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using sort orders and criterias.
            </summary>
            <param name="targetType"></param>
            <param name="orders"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using criterias.
            </summary>
            <param name="targetType"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAllByProperty(System.Type,System.String,System.Object)">
            <summary>
            Finds records based on a property value
            </summary>
            <remarks>
            Contributed by someone on the forum
            http://forum.castleproject.org/posts/list/300.page
            </remarks>
            <param name="targetType">The target type</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAllByProperty(System.Type,System.String,System.String,System.Object)">
            <summary>
            Finds records based on a property value
            </summary>
            <param name="targetType">The target type</param>
            <param name="orderByColumn">The column name to be ordered ASC</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindByPrimaryKey(System.Type,System.Object)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindByPrimaryKey(System.Type,System.Object,System.Boolean)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want to catch an exception 
            if the object is not found</param>
            <returns></returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="orders">The sort order - used to determine which record is the first one</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindOne(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="targetType">The target type</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Execute(Castle.ActiveRecord.NHibernateDelegate)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="call">The delegate instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Save">
            <summary>
            Saves the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Create">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Update">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Delete">
            <summary>
            Deletes the instance from the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Refresh">
            <summary>
            Refresh the instance from the database.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordBase`1">
            <summary>
            Base class for all ActiveRecord Generic classes. Implements all the functionality to simplify the code on the subclasses.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Register(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Internally used
            </summary>
            <param name="arType"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll">
            <summary>
            Returns all instances found for the specified type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using sort orders and criterias.
            </summary>
            <param name="orders"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using criterias.
            </summary>
            <param name="targetType"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAllByProperty(System.String,System.Object)">
            <summary>
            Finds records based on a property value
            </summary>
            <remarks>
            Contributed by someone on the forum
            http://forum.castleproject.org/posts/list/300.page
            </remarks>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAllByProperty(System.String,System.Object,NHibernate.Expression.Order[])">
            <summary>
            Finds records based on a property value
            </summary>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <param name="orders">The sort order</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Find(System.Object)">
            <summary>
            Finds an object instance by a unique ID (typically primary key)
            </summary>
            <param name="id">ID value</param>
            <exception cref="T:NHibernate.ObjectNotFoundException">if the row is not found</exception>
            <returns>T</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.TryFind(System.Object)">
            <summary>
            Finds an object instance by a unique ID (typically primary key). 
            If the row is not found this method will not throw an exception.
            </summary>
            <param name="id">ID value</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="orders">The sort order - used to determine which record is the first one</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindOne(NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Create(`0)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Update(`0)">
            <summary>
            Persists the modification on the instance state to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Save(`0)">
            <summary>
            Saves the instance to the database
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Delete(`0)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.DeleteAll(System.String)">
            <summary>
            Deletes all records of the specified type, using conditions in HQL.
            </summary>
            <param name="conditions ">HQL conditions</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.DeleteAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Removes all records with matching identifiers (typically primarykeys)
            </summary>
            <param name="pkValues"></param>
            <returns>Number of records deleted</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists``1(``0)">
            <summary>
            Check if the <paramref name="id"/> exists in the datastore.
            </summary>
            <typeparam name="PkType">The <c>System.Type</c> of the PrimaryKey</typeparam>
            <param name="id">The id to check on</param>
            <returns>True if the ID exists; otherwise false.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Execute(Castle.ActiveRecord.NHibernateDelegate,`0)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindByPrimaryKey(System.Object)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="id">ID value</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindByPrimaryKey(System.Object,System.Boolean)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want to catch an exception 
            if the object is not found</param>
            <returns></returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Execute(Castle.ActiveRecord.NHibernateDelegate)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="call">The delegate instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Save">
            <summary>
            Saves the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Create">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Update">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Refresh">
            <summary>
            Refresh the instance from the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Delete">
            <summary>
            Deletes the instance from the database.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.ActiveRecordInitializationException">
            <summary>
            Exception thrown when an error is detected on the ActiveRecord initialization phase.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordMediator">
            <summary>
            Allow programmers to use the 
            ActiveRecord functionality without direct reference
            to <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Execute(System.Type,Castle.ActiveRecord.NHibernateDelegate,System.Object)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="targetType">The target ActiveRecordType</param>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindByPrimaryKey(System.Type,System.Object,System.Boolean)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want to catch an exception 
            if the object is not found</param>
            <returns></returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindByPrimaryKey(System.Type,System.Object)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindFirst(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="orders">The sort order - used to determine which record is the first one</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindFirst(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindOne(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="targetType">The target type</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type)">
            <summary>
            Returns all instances found for the specified type.
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using sort orders and criterias.
            </summary>
            <param name="targetType"></param>
            <param name="orders"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using criterias.
            </summary>
            <param name="targetType"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Save(System.Object)">
            <summary>
            Saves the instance to the database
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Create(System.Object)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Update(System.Object)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Delete(System.Object)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.GetSessionFactoryHolder">
            <summary>
            Testing hock only.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordMediator`1">
            <summary>
            Allow programmers to use the 
            ActiveRecord functionality without direct reference
            to <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Execute(Castle.ActiveRecord.NHibernateDelegate,`0)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindByPrimaryKey(System.Object,System.Boolean)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want to catch an exception 
            if the object is not found</param>
            <returns></returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindByPrimaryKey(System.Object)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="id">ID value</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindFirst(NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="orders">The sort order - used to determine which record is the first one</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindFirst(NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindOne(NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="criterias">The criterias.</param>
            <returns>A instance the targetType or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll">
            <summary>
            Returns all instances found for the specified type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll(NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using sort orders and criterias.
            </summary>
            <param name="orders"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll(NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using criterias.
            </summary>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Save(`0)">
            <summary>
            Saves the instance to the database
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Create(`0)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Update(`0)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Delete(`0)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.GetSessionFactoryHolder">
            <summary>
            Testing hock only.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordStarter">
            <summary>
            Performs the framework initialization.
            </summary>
            <remarks>
            This class is not thread safe.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(Castle.ActiveRecord.Framework.IConfigurationSource,System.Type[])">
            <summary>
            Initialize the mappings using the configuration and 
            the list of types
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(System.Reflection.Assembly,Castle.ActiveRecord.Framework.IConfigurationSource)">
            <summary>
            Initialize the mappings using the configuration and 
            checking all the types on the specified <c>Assembly</c>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(System.Reflection.Assembly[],Castle.ActiveRecord.Framework.IConfigurationSource)">
            <summary>
            Initialize the mappings using the configuration and 
            checking all the types on the specified Assemblies
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize">
            <summary>
            Initializes the framework reading the configuration from
            the <c>AppDomain</c> and checking all the types on the executing <c>Assembly</c>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchema">
            <summary>
            Generates and executes the creation scripts for the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchemaFromFile(System.String)">
            <summary>
            Executes the specified script to create/drop/change the database schema
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchemaFromFile(System.String,System.Data.IDbConnection)">
            <summary>
            Executes the specified script to create/drop/change the database schema
            against the specified database connection
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.DropSchema">
            <summary>
            Generates and executes the Drop scripts for the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateDropScripts(System.String)">
            <summary>
            Generates and executes the drop scripts for the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateCreationScripts(System.String)">
            <summary>
            Generates the creation scripts for the database
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.ResetInitializationFlag">
            <summary>
            Intended to be used only by test cases
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.IsActiveRecordType(System.Type)">
            <summary>
            Return true if the type has a [ActiveRecord] attribute
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.ActiveRecordStarter.SessionFactoryHolderCreated">
            <summary>
            So others frameworks can intercept the 
            creation and act on the holder instance
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordValidationBase">
            <summary>
            Extends <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/> adding automatic validation support.
            <seealso cref="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid"/>
            </summary>
            <example>
            <code>
            public class Customer : ActiveRecordBase
            {
            	...
            	
            	[Property, ValidateNotEmpty]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            	
            	[Property, ValidateNotEmpty, ValidateEmail]
            	public int Email
            	{
            		get { return _email; }
            		set { _email = value; }
            	}
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase.__validators">
            <summary>
            List of validators that should be executed for this class
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase._errorMessages">
            <summary>
            List of error messages
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.#ctor">
            <summary>
            Constructs an ActiveRecordValidationBase
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.CollectValidators">
            <summary>
            Collect the validations applied to this class properties.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid">
            <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.OnNotValid">
            <summary>
            Throws an exception explaining why the save or update
            cannot be executed when fields are not ok to pass.
            </summary>
            <remarks>
            You can override this method to declare a better behavior.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase.PropertiesValidationErrorMessage">
            <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordValidationBase`1">
            <summary>
            Extends <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/> adding automatic validation support.
            <seealso cref="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid"/>
            </summary>
            <example>
            <code>
            public class Customer : ActiveRecordBase
            {
            	...
            	
            	[Property, ValidateNotEmpty]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            	
            	[Property, ValidateNotEmpty, ValidateEmail]
            	public int Email
            	{
            		get { return _email; }
            		set { _email = value; }
            	}
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase`1.__validators">
            <summary>
            List of validators that should be executed for this class
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase`1._errorMessages">
            <summary>
            List of error messages
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.#ctor">
            <summary>
            Constructs an ActiveRecordValidationBase
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.CollectValidators(System.Type)">
            <summary>
            Collect the validations applied to this class properties.
            </summary>
            <param name="targetType"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.IsValid">
            <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.OnNotValid">
            <summary>
            Throws an exception explaining why the save or update
            cannot be executed when fields are not ok to pass.
            </summary>
            <remarks>
            You can override this method to declare a better behavior.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.PropertiesValidationErrorMessage">
            <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator">
            <summary>
            Used to execute a script file to create/update/drop 
            a database schema. Inspired on NHibernate SchemaExport class.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.DictionaryAdapter">
            <summary>
            Maps keys to position in the values array. 
            Basically key -> index
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.HookDispatcher">
            <summary>
            Translates the <c>IInterceptor</c>
            messages to instance possible hooks
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnLoad(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called just before an object is initialized
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may change the <c>state</c>, which will be propagated to the persistent
            object. Note that when this method is called, <c>entity</c> will be an empty
            uninitialized instance of the class.</remarks>
            <returns><c>true</c> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnFlushDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called when an object is detected to be dirty, during a flush.
            </summary>
            <param name="currentState"></param>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the detected <c>currentState</c>, which will be propagated to
            both the database and the persistent object. Note that all flushes end in an actual
            synchronization with the database, in which as the new <c>currentState</c> will be propagated
            to the object, but not necessarily (immediately) to the database. It is strongly recommended
            that the interceptor <b>not</b> modify the <c>previousState</c>.
            </remarks>
            <returns><c>true</c> if the user modified the <c>currentState</c> in any way</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnSave(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is saved
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the <c>state</c>, which will be used for the SQL <c>INSERT</c>
            and propagated to the persistent object
            </remarks>
            <returns><c>true</c> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnDelete(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is deleted
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            It is not recommended that the interceptor modify the <c>state</c>.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.PreFlush(System.Collections.ICollection)">
            <summary>
            Called before a flush
            </summary>
            <param name="entities">The entities</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.PostFlush(System.Collections.ICollection)">
            <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
            <param name="entities">The entitites</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.IsUnsaved(System.Object)">
            <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
            <remarks>
            The return value determines if the object is saved
            <list>
            	<item><c>true</c> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item>
            	<item><c>false</c> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item>
            	<item><c>null</c> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item>
            </list>
            </remarks>
            <param name="entity">A transient entity</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.FindDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
            <remarks>
            	<list>
            		<item>an array of property indicies - the entity is dirty</item>
            		<item>an empty array - the entity is not dirty</item>
            		<item><c>null</c> - use Hibernate's default dirty-checking algorithm</item>
            	</list>
            </remarks>
            <param name="entity">A persistent entity</param>
            <param name="currentState"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <returns>An array of dirty property indicies or <c>null</c> to choose default behavior</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.Instantiate(System.Type,System.Object)">
            <summary>
            Instantiate the entity class. Return <c>null</c> to indicate that Hibernate should use the default
            constructor of the class
            </summary>
            <param name="type">A mapped type</param>
            <param name="id">The identifier of the new instance</param>
            <returns>An instance of the class, or <c>null</c> to choose default behaviour</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder">
            <summary>
            Keeps an association of SessionFactories to a object model 
            tree;
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.Register(System.Type,NHibernate.Cfg.Configuration)">
            <summary>
            Associates a Configuration object to a root type
            </summary>
            <param name="rootType"></param>
            <param name="cfg"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetAllConfigurations">
            <summary>
            Pendent
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetConfiguration(System.Type)">
            <summary>
            Requests the Configuration associated to the type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetSessionFactory(System.Type)">
            <summary>
            Obtains the SessionFactory associated to the type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.CreateSession(System.Type)">
            <summary>
            Creates a session for the associated type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.ReleaseSession(NHibernate.ISession)">
            <summary>
            Releases the specified session
            </summary>
            <param name="session"></param>
        </member>
        <member name="E:Castle.ActiveRecord.Framework.ISessionFactoryHolder.OnRootTypeRegistered">
            <summary>
            Raised when a new root type is registered. 
            A new root type creates a new <c>ISessionFactory</c>
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.ISessionFactoryHolder.ThreadScopeInfo">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.SessionFactoryHolder">
            <summary>
            Default implementation of <seealso cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            </summary>
            <remarks>
            This class is thread safe
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetAllConfigurations">
            <summary>
            Pendent
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetSessionFactory(System.Type)">
            <summary>
            Optimized with reader/writer lock.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.SessionScopeWebModule">
            <summary>
            HttpModule to set up a session for the request lifetime.
            <seealso cref="T:Castle.ActiveRecord.SessionScope"/>
            </summary>
            <remarks>
            To install the module, you must:
            <para>
               <list type="number">
                 <item>
                   <description>
                   Add the module to the <c>httpModules</c> configuration section within <c>system.web</c>
                   </description>
                 </item>
               </list>
            </para>
            </remarks>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.SupportingUtils">
            <summary>
            Contains utility methods for dealing with ActiveRecord objects
            and collections.
            Useful for external frameworks.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray(System.Type,System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to an
            strongly-typed array.
            </summary>
            <param name="type">The type of the new array</param>
            <param name="list">The source list</param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray(System.Type,System.Collections.IEnumerable,System.Int32,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to an
            strongly-typed array.
            </summary>
            <param name="type">The type of the new array</param>
            <param name="list">The source list</param>
            <param name="entityIndex">
            If the HQL clause selects more than one field, or a join is performed
            without using <c>fetch join</c>, the contents of the result list will
            be of type <c>object[]</c>. Specify which index in this array should be used to
            compose the new result array. Use <c>-1</c> to ignore this parameter.
            </param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildObjectArray(System.Type,System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to an
            strongly-typed array.
            </summary>
            <param name="type">
            The class of the object which will be created for each row contained in
            the supplied <paramref name="list"/>.
            </param>
            <param name="list">The source list</param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
            <remarks>A good alternative is to use the new <see cref="T:Castle.ActiveRecord.ImportAttribute"/></remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildObjectArray``1(System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to an
            strongly-typed array.
            </summary>
            <param name="list">The source list</param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
            <typeparam name="T">
            The class of the object which will be created for each row contained in
            the supplied <paramref name="list"/>.
            </typeparam>
            <remarks>A good alternative is to use the new <see cref="T:Castle.ActiveRecord.ImportAttribute"/></remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ValidationException.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages, if available.
            </summary>
        </member>
    </members>
</doc>
