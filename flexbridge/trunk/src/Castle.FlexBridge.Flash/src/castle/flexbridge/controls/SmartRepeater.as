// Copyright 2007 Castle Project - http://www.castleproject.org/
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package castle.flexbridge.controls
{
	// Unfortunately we require use of some internal properties.
	//
	// - UIComponentGlobals.layoutManager is required to access the layout manager
	//   and though the internal documentation discusses how it may be
	//   set in the Application's constructor normal client code does not
	//   have access to do so without importing the mx_internal namespace.
	// - UIComponentDescriptor.repeaterIndices, instanceIndices and repeaters
	//   must all be set before child components are created by the repeater
	//   as otherwise a check in the Container.createComponentFromDescriptor
	//   method fails because it detects duplicate components within the
	//   container with the same descriptor.  Repeaters are apparently supposed
	//   to exempt themselves by having set these properties beforehand but
	//   they're in the mx_internal namespace.
	// - getItemAt is called by the code generated by the MXML compiler.
	//   Nothing can be done about it.
	import mx.core.mx_internal;
	use namespace mx_internal;

	import mx.core.UIComponent;
	import mx.core.IRepeater;
	import flash.errors.IllegalOperationError;
	import mx.core.Container;
	import mx.collections.ICollectionView;
	import mx.events.CollectionEvent;
	import mx.collections.ArrayCollection;
	import mx.collections.ListCollectionView;
	import mx.collections.IList;
	import mx.events.CollectionEventKind;
	import flash.utils.Dictionary;
	import flash.display.DisplayObject;
	import mx.core.IRepeaterClient;
	import mx.core.IDeferredInstantiationUIComponent;
	import mx.collections.XMLListCollection;
	import mx.events.FlexEvent;
	import mx.collections.IViewCursor;
	import mx.collections.CursorBookmark;
	import mx.collections.errors.ItemPendingError;
	import mx.core.IFlexDisplayObject;
	import mx.core.UIComponentDescriptor;
	import mx.core.IContainer;
	import mx.core.ContainerCreationPolicy;
	import mx.managers.LayoutManager;
	import mx.core.Repeater;
	import flash.events.Event;
	import mx.core.UIComponentGlobals;
	import mx.core.IUIComponent;
	import mx.automation.IAutomationObject;
	import castle.flexbridge.collections.CollectionDelta;
	import castle.flexbridge.collections.CollectionUtils;
	import castle.flexbridge.collections.ArrayUtils;

	[Event(name="repeat", type="mx.events.FlexEvent")]
	[Event(name="repeatEnd", type="mx.events.FlexEvent")]
	[Event(name="repeatStart", type="mx.events.FlexEvent")]
	
	/**
	 * A smarter Repeater control.
	 * 
	 * This control is much more efficient than the Flex Repeater about
	 * how it handles incremental updates to the underlying data provider.
	 * Updates to the display list are deferred and batched when the
	 * layout manager commits the properties.
	 * 
	 * TODO: Support ItemPendingError.
	 * TODO: Support nested repeaters.
	 *       Need improved handling of repeater and instance indices.
	 * TODO: Support sharing a container with other repeaters or fixed controls.
	 *       Currently the repeater always inserts at the beginning of its container
	 *       so it is not possible to include other components that appear before
	 *       or after the repeated ones.
	 */
	// HACK: Must be a subclass of Repeater due to some apparent hardcoding in
	//       the MXML compiler.  Otherwise the instance property on the document
	//       associated with the repeater components' id's are defined as scalars
	//       rather than arrays.  However if not extending Repeater then we must
	//       extend IContainer so the compiler makes sure to populate the
	//       child descriptors property, except it's still not quite enough to
	//       compensate for the rest of the component magic we're missing out on.
	//       Naturally extending Repeater makes a real mess of things.  -- Jeff.
	public class SmartRepeater extends /*UIComponent*/ Repeater implements IRepeater
	{
		private static const EMPTY_ARRAY:Array = [];
		
		private var _childDescriptors:Array = null;
		private var _childDescriptorCount:int = 0;
		
		private var _repeatersIncludingSelf:Array = [ this ];
		private var _childRepeaterIndicesPrototype:Array = [ 0 ];
		private var _childInstanceIndicesPrototype:Array = [ 0 ];
		
		private var _container:Container;
		
		private var _currentIndex:int = -1;
		private var _currentItem:Object = null;
		private var _recycleChildren:Boolean = false;
		
		private var _dataProvider:Object = null;
		private var _dataProviderChanged:Boolean = true;
		
		private var _collection:ICollectionView = null;
		private var _collectionCursor:IViewCursor = null;
		
		private var _startingIndex:int = 0;
		private var _startingIndexChanged:Boolean = true;
		
		private var _count:int = -1;
		private var _countChanged:Boolean = true;
		
		/**
		 * The next available instance index.
		 * When recycling children, we do not bother to update their instance
		 * indices because they have no particular significance except to allocate
		 * a slot within the parent document.  We track the next available index
		 * so that we do not accidentally reallocate one.  A simple counter suffices.
		 * We reset it whenever we do a full refresh to avoid letting the underlying
		 * arrays get too big.
		 */
		private var _nextInstanceIndex:int = 0;
		
		/**
		 * The item map maps item indexes to their corresponding display
		 * objects.  When the collection changes, we update the map immediately
		 * but defer updates to the display object hierarchy until commitProperties.
		 * 
		 * The map is an array of display objects at consecutive indexes beginning
		 * with the base index.  Some elements may be null to indicate that
		 * the display object for that index must be recreated.
		 */
		private var _itemMap:Array = new Array() /*of RepeaterItem*/;
		private var _itemMapBaseIndex:int = 0;
		private var _itemMapChanged:Boolean = true;
		private var _pendingRefresh:Boolean = true;
		
		/**
		 * The list of item map orphans is used to ensure that the display
		 * objects associated with items that are removed from the item map
		 * are properly cleaned up.
		 */
		private var _itemOrphans:Array = new Array() /*of RepeaterItem*/;
		
		/**
		 * The list of recycled objects is a pool of display objects that were
		 * allocated but no longer appear in the item map due to changes in
		 * the collection.  During commitProperties some of these objects may
		 * be reused to create new repeater items but the remainder will be discarded.
		 */
		private var _itemPool:Array = new Array();
		
		/**
	     * An Array of UIComponentDescriptor objects for this Repeater's children.
	     * This property is set by the MXML compiler.
	     */
// HACK: Due to required subclassing of Repeater class we can't do what we want
//       because we cannot override the base implementation.
//	    public override function get childDescriptors():Array /* of UIComponentDescriptor */
//	    {
//	    	return _childDescriptors;
//	    }
//	    
//	    public override function set childDescriptors(value:Array):void
//	    {
//	    	setChildDescriptors(value);
//	    }

		private function setChildDescriptors(value:Array):void
		{
			// Saving the count is a simple optimization that allows us to
	    	// skip checking _childDescriptors for nullity and zero length in
	    	// a few places.  Similarly, we don't need to keep checking
	    	// that the descriptor's document has been set if we just do it once.
	    	_childDescriptors = value;
	    	
	    	if (value)
	    	{
	    		_childDescriptorCount = value.length;
	    		
	    		for each (var descriptor:UIComponentDescriptor in value)
	    			if (! descriptor.document)
		    			descriptor.document = document;
	    	}
	    	else
	    	{
	    		_childDescriptorCount = 0;
	    	}
		}
	    
	    /**
	     * For efficiency, we override this method to cache an array of
	     * child repeaters including self.  We reuse that array across all
	     * children.
	     */
	    public override function set repeaters(value:Array):void
	    {
	    	super.repeaters = value;
	    	
	    	if (value)
	    	{
		    	_repeatersIncludingSelf = value.slice(0);
		    	_repeatersIncludingSelf.push(this);	    		
	    	}
	    	else
	    	{
	    		_repeatersIncludingSelf = [ this ];
	    	}
	    }
	    
	    /**
	     * For efficiency, we maintain a prototypical array used to create
	     * indices arrays for children.  By cloning it we already have an array
	     * of exactly the right size and need only set its last component.
	     */
	    public override function set instanceIndices(value:Array):void
	    {
	    	super.instanceIndices = value;
	    	
	    	if (value)
	    	{
	    		_childInstanceIndicesPrototype = value.slice(0);
	    		_childInstanceIndicesPrototype.push(0);
	    	}
	    	else
	    	{
	    		_childInstanceIndicesPrototype = [ 0 ];
	    	}
	    }

	    /**
	     * For efficiency, we maintain a prototypical array used to create
	     * indices arrays for children.  By cloning it we already have an array
	     * of exactly the right size and need only set its last component.
	     */
	    public override function set repeaterIndices(value:Array):void
	    {
	    	super.repeaterIndices = value;
	    	
	    	if (value)
	    	{
	    		_childRepeaterIndicesPrototype = value.slice(0);
	    		_childRepeaterIndicesPrototype.push(0);
	    	}
	    	else
	    	{
	    		_childRepeaterIndicesPrototype = [ 0 ];
	    	}
	    }
		
		/**
		 * @inheritDoc
		 */
		public override function get container():Container
		{
			return _container;
		}
		
		/**
		 * @inheritDoc
		 */
		[Bindable(event="dataProviderChanged")]
		public override function get dataProvider():Object
		{
			return _dataProvider;
		}
		
		public override function set dataProvider(value:Object):void
		{
			if (_dataProvider != value)
			{
				_dataProvider = value;
				_dataProviderChanged = true;
				
				invalidateProperties();
				dispatchEvent(new Event("dataProviderChanged"));
			}
			else
			{
				// Assume a refresh if the data provider has been set anew.
				// This enables data binding to work properly since the
				// data provider reference may not have changed but its
				// substructure might have.
				refresh();
			}
		}
		
		/**
		 * @inheritDoc
		 */
		[Bindable(event="countChanged")]
		public override function get count():int
		{
			return _count;
		}
		
		public override function set count(value:int):void
		{
			if (_count != value)
			{
				_count = value;
				_countChanged = true;
				
				invalidateProperties();
				dispatchEvent(new Event("countChanged"));
			}
		}
		
		/**
		 * @inheritDoc
		 */
		[Bindable(event="startingIndexChanged")]
		public override function get startingIndex():int
		{
			return _startingIndex;
		}
		
		public override function set startingIndex(value:int):void
		{
			if (_startingIndex != value)
			{
				_startingIndex = value;
				_startingIndexChanged = true;
				
				invalidateProperties();
				dispatchEvent(new Event("startingIndexChanged"));
			}
		}
		
		/**
		 * @inheritDoc
		 */
		[Bindable(event="recycleChildrenChanged")]
		public override function get recycleChildren():Boolean
		{
			return _recycleChildren;
		}
		
		public override function set recycleChildren(value:Boolean):void
		{
			if (_recycleChildren != value)
			{
				_recycleChildren = value;
				
				if (! _recycleChildren)
				{
					clearItemPool();
				}
					
				dispatchEvent(new Event("recycleChildrenChanged"));
			}
		}
		
		/**
		 * @inheritDoc
		 */
		[Bindable(event="repeat")]
		public override function get currentIndex():int
		{
			return _currentIndex;
		}
		
		/**
		 * @inheritDoc
		 */
		[Bindable(event="repeat")]
		public override function get currentItem():Object
		{
			return _currentItem;
		}
		
		/**
		 * Causes the repeater to refresh its contents.
		 * This function may be useful when the data provider does not
		 * provide change events.
		 */
		public function refresh():void
		{
			if (_pendingRefresh || _dataProviderChanged)
				return;
				
			handleResetOrRefresh();
		}
		
		/**
		 * @inheritDoc
		 */
		public override function executeChildBindings():void
		{
			// Execute bindings for all deferred children.
			for each (var repeaterItem:RepeaterItem in _itemMap)
			{
				if (repeaterItem)
				{
					for each (var child:UIComponent in repeaterItem.components)
					{
						var deferredChild:IDeferredInstantiationUIComponent = child as IDeferredInstantiationUIComponent;
						if (deferredChild)
							deferredChild.executeBindings();
					}
				}
			}
		}
		
		/**
		 * @inheritDoc
		 */
		public override function initializeRepeater(container:Container, recurse:Boolean):void
		{
			// HACK: Due to required subclassing of Repeater class.
			setChildDescriptors(childDescriptors);
			
			_container = container;
			
			// Set the nesting level such that the repeater properties are committed
			// before the container's if possible because the repeater may modify
			// the container.
			nestLevel = Math.max(_container.nestLevel - 1, 0);
			
			_pendingRefresh = true;
			invalidateProperties();
		}

	    /**
	     * HACK: It appears that the MXML compiler knows about this method and
	     *       generates code to call it when binding to the repeater's current
	     *       item instead of using the currentItem as we might expect.
	     */
	    mx_internal override function getItemAt(index:int):Object
	    {
	        if (_collectionCursor)
	        {
	            try
	            {
					_collectionCursor.seek(CursorBookmark.FIRST, index);
					return _collectionCursor.current;
				}
				catch (e:ItemPendingError)
				{
					// TODO: Handle this case by causing the repeat event to reoccur
					//       and rebinding.
				}
	        }
	        
	        return null;
	    }
		
		/**
		 * HACK: Because the repeater is not a part of the display list, the
		 *       framework code does not notify the layout manager that it
		 *       wishes to participate in the commit portion of the rendering
		 *       lifecycle.  The framework implementation of Repeater does not
		 *       do this and instead processes all changes synchronously which
		 *       can be very inefficient but then it does not encounter this problem.
		 */
		public override function invalidateProperties():void
		{
			if (! invalidatePropertiesFlag)
			{
				invalidatePropertiesFlag = true;
				UIComponentGlobals.layoutManager.invalidateProperties(this);
			}
		}
		
		protected override function commitProperties():void
		{
			// Commented out because we don't actually require anything that
			// the base class has to offer.  -- Jeff.
			//super.commitProperties();
			
			// Handle data provider changes.
			if (_dataProviderChanged)
			{
				_dataProviderChanged = false;

				if (_collection)
				{
					_collection.removeEventListener(CollectionEvent.COLLECTION_CHANGE, collectionChangeHandler);
					_collection = null;
					_collectionCursor = null;
				}
				
				if (_dataProvider is ICollectionView)
				{
					_collection = ICollectionView(_dataProvider);
				}
				else if (_dataProvider is Array)
				{
					_collection = new ArrayCollection(_dataProvider as Array);
				}
				else if (_dataProvider is IList)
				{
					_collection = new ListCollectionView(IList(_dataProvider));
				}
		        else if (_dataProvider is XMLList || _dataProvider is XML)
		        {
		            _collection = new XMLListCollection(XMLList(_dataProvider));
		        }
		        else if (_dataProvider != null)
		        {
		            _collection = new ArrayCollection([ _dataProvider ]);
		        }
		        
		        if (_collection)
		        {
		        	// Use weak reference so that the control can be garbage collected
		        	// in a timely fashion.
		        	_collection.addEventListener(CollectionEvent.COLLECTION_CHANGE, collectionChangeHandler, false, 0, true);
		        	_collectionCursor = _collection.createCursor();
		        }
		        
				_pendingRefresh = true;
			}
			
			// Handle pending refresh.
			if (_pendingRefresh)
			{
				_pendingRefresh = false;
				
				trackItemOrphans(_itemMap);
				_itemMap.length = 0;
				_itemMapChanged = true;
			}
			
			// Adjust the visible window.
			if (_countChanged || _startingIndexChanged || _itemMapChanged)
			{
				_countChanged = false;
				_startingIndexChanged = false;

				// Compute portion of collection that is visible.
				var collectionCount:int = _collection != null ? _collection.length : 0;
				var visibleCount:int = Math.max(0, collectionCount - _startingIndex);
				if (_count >= 0 && _count < visibleCount)
					visibleCount = _count;
				
				adjustItemMapWindow(_startingIndex, visibleCount);
			}
			
			// Update the contents of the repeater.
			if (_itemMapChanged && _container)
			{
				_itemMapChanged = false;
				
				removeOrphanedItems();
				updateItems();
			}
		}
		
		/**
		 * Applies changes to the item map then sets a flag to ensure we
		 * update the display object hierarchy eventually.
		 */
		private function collectionChangeHandler(e:CollectionEvent):void
		{
			if (_pendingRefresh || _dataProviderChanged)
				return; // no need to track changes if we're just going to refresh
				
			if (e.kind == CollectionEventKind.UPDATE)
				return; // don't care about changes to the items themselves
				
			var deltas:Array = CollectionUtils.convertCollectionEventToDeltas(e);
			for each (var delta:CollectionDelta in deltas)
			{
				switch (e.kind)
				{
					case CollectionEventKind.REFRESH:
					case CollectionEventKind.RESET:
						handleResetOrRefresh();
						break;
						
					case CollectionEventKind.ADD:
						handleItemsAdded(e.location, e.items.length);
						break;
					
					case CollectionEventKind.REMOVE:
						handleItemsRemoved(e.location, e.items.length);
						break;
						
					case CollectionEventKind.MOVE:
						handleItemMoved(e.oldLocation, e.location);
						break;
						
					case CollectionEventKind.REPLACE:
						handleItemReplaced(e.location);
						break;
				}
			}
		}
		
		private function handleResetOrRefresh():void
		{
			// Try to rebuild the item map by computing new indices of elements.
			// This takes advantage of sparse arrays to avoid allocating a lot
			// of storage even when the items end up scattered all over.
			var newItemMap:Array = [ ];
			if (_itemMap.length)
			{
				// Note we're only looping over properties of the array that
				// actually exist.  This is to avoid redundant work examining
				// non-populated indices in case the item map is already sparse.
				var searchItems:Array = [ ];
				for (var indexProp:String in _itemMap)
				{
					var index:int = int(indexProp);
					var item:RepeaterItem = RepeaterItem(_itemMap[index]);
					
					if (item.value !== undefined)
					{
						// Look in the collection at the same index to see if we find
						// a match.  This yields a significant performance boost in the
						// common case where the refresh does not actually change the
						// item indices at all.
						if (item.value === getItemAt(index))
						{
							newItemMap[index] = item;
						}
						else
						{
							// The item might still appear elsewhere add it to the search list.
							searchItems.push(item);
						}
					}
					else
					{
						// Item has no value so we must sacrifice it.
						trackItemOrphan(item);
					}
				}
				
				var searchCount:int = searchItems.length;
				if (searchCount)
				{
					try
					{
						var searchIndex:int = 0;
						
						// Search from beginning to end for remaining items.
						_collectionCursor.seek(CursorBookmark.FIRST, - 1, _collection.length);
						while (_collectionCursor.moveNext())
						{
							if (! (searchIndex in newItemMap))
							{
								var current:Object = _collectionCursor.current;
								var j:int;
								
								for (j = 0; j < searchCount; j++)
								{
									if (searchItems[j].value === current)
										break;
								}
								
								if (j < searchCount)
								{
									// Found an item.  Remove the value from consideration and continue.
									newItemMap[searchIndex] = searchItems[j];
									searchCount -= 1;
									searchItems.splice(j, 1);
									
									if (searchCount == 0)
										break; // no more work left
								}
							}
							
							searchIndex += 1;
						}
					}
					catch (e:ItemPendingError)
					{
						// Just give up and refresh everything.
					}
					
					// Any remaining items we couldn't remap must be sacrificed.
					trackItemOrphans(searchItems);
				}
			}
			
			// Refresh everything soon.
			_itemMapBaseIndex = 0;
			_itemMap = newItemMap;
			_itemMapChanged = true;
			
			if (_itemMap.length == 0)
			{
				// If we did not manage to salvage any items then schedule a full refresh.
				_pendingRefresh = true;
			}
			
			invalidateProperties();
		}
		
		private function handleItemsAdded(index:int, count:int):void
		{
			var offset:int = index - _itemMapBaseIndex;
			
			if (offset <= 0)
			{
				// All items inserted before the mapped area. 
				_itemMapBaseIndex += count;
			}
			else if (offset < _itemMap.length)
			{
				// Items inserted within the mapped area.
				// Since arrays are sparse, we can move the elements after
				// the insertion point to where they belong without consuming
				// extra storage to fill in the hole even if count is large.
				ArrayUtils.move(_itemMap, offset, _itemMap, offset + count, count);
			}
			else if (index + count >= _startingIndex &&
				(_count < 0 || index <= _startingIndex + _count))
			{
				// Items inserted beyond the mapped area but within the visible range.
				// Fall through to set map changed flag but we don't actually
				// update the map itself at this time.  That will be taken care of by the
				// adjustItemMapWindow method later on.
			}
			else
			{
				// Items inserted outside of map and beyond visible page.
				return;
			}
			
			_itemMapChanged = true;
			invalidateProperties();
		}
		
		private function handleItemsRemoved(index:int, count:int):void
		{
			var offset:int = index - _itemMapBaseIndex;
			var endOffset:int = offset + count;
			
			if (endOffset <= 0)
			{
				// All items removed are before the mapped area.
				_itemMapBaseIndex -= count;
			}
			else if (offset <= 0)
			{
				// Items removed from the beginning of the mapped area.
				trackItemOrphans(_itemMap.splice(0, count + offset));
				_itemMapBaseIndex += offset;
			}
			else if (offset < _itemMap.length)
			{
				// Items removed from within the mapped area but not at the beginning.
				trackItemOrphans(_itemMap.splice(offset, count));
			}
			else
			{
				// Items removed from beyond mapped area.
				return;
			}
			
			_itemMapChanged = true;
			invalidateProperties();
		}

		private function handleItemMoved(oldIndex:int, newIndex:int):void
		{
			var oldOffset:int = oldIndex - _itemMapBaseIndex;
			var newOffset:int = newIndex - _itemMapBaseIndex;
			
			if (oldOffset >= 0 && oldOffset < _itemMap.length
				&& newOffset >= 0 && newOffset < _itemMap.length)
			{
				// Item moved within mapped area.
				var movedItem:Array = _itemMap.splice(oldOffset, 1);
				_itemMap.splice(newOffset, 0, movedItem);
				_itemMapChanged = true;
				invalidateProperties();
			}
			else
			{
				// Item moved from or to a region outside mapped area.
				handleItemsRemoved(oldIndex, 1);
				handleItemsAdded(newIndex, 1);
			}
		}
		
		private function handleItemReplaced(index:int):void
		{
			var offset:int = index - _itemMapBaseIndex;
			
			if (offset >= 0 && offset < _itemMap.length)
			{
				// Item replaced within mapped area.
				trackItemOrphan(_itemMap[offset]);
				delete _itemMap[offset];
				_itemMapChanged = true;
				invalidateProperties();
			}
		}
		
		/**
		 * Adds non-null elements of the array to the item map orphans array.
		 */
		private function trackItemOrphans(children:Array):void
		{
			for each (var child:RepeaterItem in children)
				trackItemOrphan(child);
		}
		
		/**
		 * Adds the child to the item map orphans array if non-null.
		 */
		private function trackItemOrphan(child:RepeaterItem):void
		{
			if (child)
				_itemOrphans.push(child);
		}
		
		/**
		 * Adjusts the region of the collection covered by the item map.
		 */
		private function adjustItemMapWindow(newBaseIndex:int, newCount:int):void
		{
			var oldCount:int = _itemMap.length;
			var newStartOffset:int = newBaseIndex - _itemMapBaseIndex;
			var newEndOffset:int = newStartOffset + newCount;
			
			if (newEndOffset <= 0 || newStartOffset >= oldCount)
			{
				// Regions have nothing in common.
				trackItemOrphans(_itemMap);
				
				_itemMap = new Array(newCount);
				_itemMapBaseIndex = newBaseIndex;
				_itemMapChanged = true;
			}
			else if (newStartOffset != 0 || newEndOffset != oldCount)
			{
				// Regions partly intersect.
				if (newEndOffset > oldCount)
				{
					ArrayUtils.insertArray(_itemMap, oldCount, new Array(newEndOffset - oldCount));
				}
				else if (newEndOffset < oldCount)
				{
					trackItemOrphans(_itemMap.splice(newEndOffset, oldCount - newEndOffset));
				}
				
				if (newStartOffset > 0)
				{
					trackItemOrphans(_itemMap.splice(0, newStartOffset));
				}
				else if (newStartOffset < 0)
				{
					ArrayUtils.insertArray(_itemMap, 0, new Array(- newStartOffset));
				}
				
				_itemMapBaseIndex = newBaseIndex;
				_itemMapChanged = true;
			} // Otherwise regions overlap exactly.
		}
		
		/**
		 * Removes display objects for all item map orphans.
		 * If recycling is enabled, places the removed items into the recycled
		 * item pool so they can be reused.
		 */
		private function removeOrphanedItems():void
		{
			var orphanCount:int = _itemOrphans.length;
			if (orphanCount == 0)
				return;
			
			// Remove children from back to front for efficiency.
			for (var i:int = orphanCount - 1; i >=0; i--)
			{
				var orphan:RepeaterItem = _itemOrphans[i];
				orphan.value = undefined;
				
				for (var j:int = orphan.components.length - 1; j >= 0; j--)
				{
					var child:UIComponent = orphan.components[j];
					
					container.removeChild(child);
					
					// We do not delete the reference on the parent document
					// because the array used to hold instances is spliced as
					// as result and the instance indices of subsequent children
					// become invalid!
					//child.deleteReferenceOnParentDocument(document);
				}
			}
			
			// If recycling children, add them to the pool.
			if (_recycleChildren)
			{
				ArrayUtils.pushArray(_itemPool, _itemOrphans);
			}
			
			// Reset the next available instance index when nothing remains.
			if (_itemPool.length == 0 && _itemMap.length == 0)
			{
				clearAllComponentReferencesOnParentDocument();
			}
			else if (! _recycleChildren)
			{
				clearComponentReferencesOnParentDocument(_itemOrphans);
			}
			
			// Now wipe the array.
			_itemOrphans.length = 0;			
		}
		
		/**
		 * Safely removes the component references on the parent document for
		 * the specified items.  We do it this way because the
		 * UI.deleteReferenceOnParentDocument method has the undesirable side-effect
		 * of removing elements from the array of references so that its structure
		 * no longer corresponds to the correct component indices (unless we
		 * do extra work to update them subsequently).
		 * 
		 * @param items The array of items whose components should be unreferenced.
		 */
		private function clearComponentReferencesOnParentDocument(items:Array):void
		{
			for (var i:int = 0; i < _childDescriptorCount; i++)
			{
				// TODO: Handle case of nested repeaters.
				var instances:Array = document[UIComponentDescriptor(_childDescriptors[i]).id] as Array;
				
				if (instances)
				{
					for each (var item:RepeaterItem in items)
					{
						// Delete the reference from the array of instances.
						// Note that since Arrays are sparse, this does not affect
						// the position of subsequent instances or the length of the Array.
						delete instances[item.instanceIndex];
					}
				}
			}
		}
		
		/**
		 * Clears all component references on the parent document for all items.
		 * Assumes that the components no longer exist.
		 * Also resets the next instance index to zero.
		 */
		private function clearAllComponentReferencesOnParentDocument():void
		{
			// Clear the document's array of component references all at once.
			for (var i:int = 0; i < _childDescriptorCount; i++)
			{
				// TODO: Handle case of nested repeaters.
				document[UIComponentDescriptor(_childDescriptors[i]).id] = null;
			}
			
			_nextInstanceIndex = 0;
		}

		/**
		 * Clears the item pool.
		 */
		private function clearItemPool():void
		{
			clearComponentReferencesOnParentDocument(_itemPool);
			
			_itemPool.length = 0;
		}
				
		/**
		 * Updates all items, creating or recycling any that are missing from
		 * the item map and performs data binding.
		 * The repeatStart, repeat and repeatEnd events are fired as needed.
		 */
		private function updateItems():void
		{
			// Start the repeater iteration cycle.
			dispatchEvent(new FlexEvent(FlexEvent.REPEAT_START));
			
			try
			{
				var itemCount:int = _itemMap.length;
				if (itemCount > 0)
				{
					// Iterate over all repeater items.
					var childIndex:int = 0;
					for (var i:int = 0; i < itemCount; i++)
					{
						// Get the current item and obtain its value.
						_currentIndex = i + _itemMapBaseIndex;

						var item:RepeaterItem = RepeaterItem(_itemMap[i]);
						var itemValue:*;
						if (item && item.value !== undefined)
						{
							itemValue = item.value;
						}
						else
						{
							try
							{
								// The prefetch range is set to cover the remainder of the mapped item window.
								var prefetch:int = itemCount - i - 1;
								_collectionCursor.seek(CursorBookmark.FIRST, _currentIndex, prefetch);
								itemValue = _collectionCursor.current;
							}
							catch (e:ItemPendingError)
							{
								// TODO: Handle this case by causing the repeat event to reoccur
								//       and rebinding.
								itemValue = undefined;
							}
						}
						
						_currentItem = Object(itemValue);
						
						// Ensure the component has been created.
						if (! item)
						{
							// Create the item map entry and its components.
							//trace('i: ' + i + ' missing');
							item = createOrRecycleItem(_currentIndex);
							_itemMap[i] = item;
						}
						else
						{
							// Update the item's repeater indices.
							//trace('i: ' + i + ' update');
							updateRepeaterIndices(item, _currentIndex);
						}
						
						// Save the item's value.
						item.value = itemValue;
			    		
	    	            // Execute bindings that are watching currentIndex or currentItem.
						dispatchEvent(new FlexEvent(FlexEvent.REPEAT));

						// Add the component to its parent if needed and set its index
						// appropriately.
			    		for each (var child:DisplayObject in item.components)
			    		{
			    			if (child.parent)
				    			container.setChildIndex(child, childIndex++);
				    		else
				    			container.addChildAt(child, childIndex++);
			    			
							var deferredChild:IDeferredInstantiationUIComponent = child as IDeferredInstantiationUIComponent;
							if (deferredChild)
								deferredChild.executeBindings(true);
			    		}
					}
				}
			}
			finally
			{
				// End the repeater iteration cycle.
				_currentIndex = -1;
				_currentItem = null;
				dispatchEvent(new FlexEvent(FlexEvent.REPEAT_END));
			}
		}
		
		/**
		 * Obtains an item from the recycled pool if available or creates a new one.
		 */
		private function createOrRecycleItem(repeaterIndex:int):RepeaterItem
		{
			var item:RepeaterItem;
			
			if (_recycleChildren && _itemPool.length > 0)
			{
				item = RepeaterItem(_itemPool.pop());
				updateRepeaterIndices(item, repeaterIndex);
			}
			else
			{
				item = new RepeaterItem();
				
				if (_childDescriptorCount > 0)
				{
					var instanceIndex:int = _nextInstanceIndex++;
					
					item.components = new Array(childDescriptors.length);

					var childInstanceIndices:Array = _childInstanceIndicesPrototype.slice(0);
					childInstanceIndices[_childInstanceIndicesPrototype.length - 1] = instanceIndex;
					
					var childRepeaterIndices:Array = _childRepeaterIndicesPrototype.slice(0);
					childRepeaterIndices[_childRepeaterIndicesPrototype.length - 1] = repeaterIndex;
					
					for (var i:int = 0; i < _childDescriptorCount; i++)
					{
						var descriptor:UIComponentDescriptor = _childDescriptors[i];
						
						// Set some special descriptor properties before creating the component.
						// Note: These properties are in mx_internal.  We could also set
						//       them using the public properties on IRepeaterClient but
						//       it turns out that there is a check for component uniqueness
						//       from which repeaters are only exempted if they set these
						//       properties in the descriptor instead!
						descriptor.repeaters = _repeatersIncludingSelf;
						descriptor.instanceIndices = childInstanceIndices;
						descriptor.repeaterIndices = childRepeaterIndices;
						
						// From the original Flex Repeater component:
				        //   "Do not reuse the descriptor's properties, because we don't want repeated items
				        //    to share non scalar properties.  Otherwise they will have references to the
				        //    same objects as opposed to having their own instances."
				        descriptor.invalidateProperties();
				        
						var component:IFlexDisplayObject = _container.createComponentFromDescriptor(descriptor, true);
						item.components[i] = component;
						item.repeaterIndex = repeaterIndex;
						item.instanceIndex = instanceIndex;
						
						// Now that that's done, clear the special descriptor properties.
						descriptor.repeaters = null;
						descriptor.instanceIndices = null;
						descriptor.repeaterIndices = null;
						
						// Set the owner of the component to the Repeater itself.
                        if (component is IUIComponent)
                        	 IUIComponent(component).owner = this;

						// Ensure that the repeated component appears in the automation hierarchy.
						// It seems that it might not by default because of how it is created?  -- Jeff.
                        if (component is IAutomationObject)
                        	 IAutomationObject(component).showInAutomationHierarchy = true;						
					}
				}
				else
				{
					item.components = EMPTY_ARRAY;
				}
			}
			
			return item;
		}
		
		/**
		 * Updates the repeater indices of the specified item if needed.
		 */
		private function updateRepeaterIndices(item:RepeaterItem, repeaterIndex:int):void
		{
			if (item.repeaterIndex == repeaterIndex)
				return; // nothing to do
			
			var childRepeaterIndices:Array = _childRepeaterIndicesPrototype.slice(0);
			childRepeaterIndices[_childRepeaterIndicesPrototype.length - 1] = repeaterIndex;

			for (var i:int = 0; i < _childDescriptorCount; i++)
			{
				recursivelySetRepeaterIndices(IRepeaterClient(item.components[i]), childRepeaterIndices);
			}
			
			item.repeaterIndex = repeaterIndex;
		}
		
		/**
		 * Recursively sets the repeaterIndices property of the component and
		 * all of its children if it is a Container or Repeater.
		 */
		private function recursivelySetRepeaterIndices(component:IRepeaterClient, repeaterIndices:Array):void
		{
			// Set the repeater indices for the component.
			component.repeaterIndices = repeaterIndices;

			// Do not recurse inside child documents.
			// Each document describes its own scope of repeaters with their own indices.
			if (component.isDocument)
				return;
			
			// Recurse into all child components.
			var container:Container = component as Container;
			if (container)
			{
	            var count:int = container.numChildren;
	            
	            for (var i:int = 0; i < count; i++)
	            {
	            	recursivelySetRepeaterIndices(IRepeaterClient(container.getChildAt(i)), repeaterIndices);
	            }
			}
		}
   	}
}

/**
 * An item map entry contains information about the display objects associated
 * with a given item of the data provider.
 */
final class RepeaterItem
{
	/**
	 * The array of display objects associated with this entry.
	 */
	public var components:Array /*of DisplayObject / IRepeaterClient*/;
	
	/**
	 * The repeater index currently assigned to this item.
	 */
	public var repeaterIndex:int;
	
	/**
	 * The instance index currently assigned to this item.
	 */
	public var instanceIndex:int;
	
	/**
	 * The value bound to the repeater item or undefined if none.
	 */
	public var value:*;
}
